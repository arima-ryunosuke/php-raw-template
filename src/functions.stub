<?php
# Don't touch this code. This is auto generated.
namespace ryunosuke\NightDragon;

if (!defined('ryunosuke\\NightDragon\\IS_OWNSELF')) {
    define('ryunosuke\\NightDragon\\IS_OWNSELF', 2);
}

if (!defined('ryunosuke\\NightDragon\\IS_PUBLIC')) {
    define('ryunosuke\\NightDragon\\IS_PUBLIC', 4);
}

if (!defined('ryunosuke\\NightDragon\\IS_PROTECTED')) {
    define('ryunosuke\\NightDragon\\IS_PROTECTED', 8);
}

if (!defined('ryunosuke\\NightDragon\\IS_PRIVATE')) {
    define('ryunosuke\\NightDragon\\IS_PRIVATE', 16);
}

if (!defined('ryunosuke\\NightDragon\\EN_MONTH_SHORT')) {
    define('ryunosuke\\NightDragon\\EN_MONTH_SHORT', [
        1  => "jan",
        2  => "feb",
        3  => "mar",
        4  => "apr",
        5  => "may",
        6  => "jun",
        7  => "jul",
        8  => "aug",
        9  => "sep",
        10 => "oct",
        11 => "nov",
        12 => "dec",
    ]);
}

if (!defined('ryunosuke\\NightDragon\\EN_MONTH_LONG')) {
    define('ryunosuke\\NightDragon\\EN_MONTH_LONG', [
        1  => "january",
        2  => "february",
        3  => "march",
        4  => "april",
        5  => "may",
        6  => "june",
        7  => "july",
        8  => "august",
        9  => "september",
        10 => "october",
        11 => "november",
        12 => "december",
    ]);
}

if (!defined('ryunosuke\\NightDragon\\JP_ERA')) {
    define('ryunosuke\\NightDragon\\JP_ERA', [
        [
            "name"  => "令和",
            "abbr"  => "R",
            "since" => 1556636400,
        ],
        [
            "name"  => "平成",
            "abbr"  => "H",
            "since" => 600188400,
        ],
        [
            "name"  => "昭和",
            "abbr"  => "S",
            "since" => -1357635600,
        ],
        [
            "name"  => "大正",
            "abbr"  => "T",
            "since" => -1812186000,
        ],
        [
            "name"  => "明治",
            "abbr"  => "M",
            "since" => -3216790800,
        ],
    ]);
}

if (!defined('ryunosuke\\NightDragon\\GENERAL_MIMETYPE')) {
    define('ryunosuke\\NightDragon\\GENERAL_MIMETYPE', [
        "csv"   => "text/csv",
        "dcm"   => "application/dicom",
        "dvc"   => "application/dvcs",
        "finf"  => "application/fastinfoset",
        "stk"   => "application/hyperstudio",
        "ipfix" => "application/ipfix",
        "json"  => "application/json",
        "mrc"   => "application/marc",
        "nb"    => "application/mathematica",
        "ma"    => "application/mathematica",
        "mb"    => "application/mathematica",
        "mbox"  => "application/mbox",
        "m21"   => "application/mp21",
        "mp21"  => "application/mp21",
        "xls"   => "application/vnd.ms-excel",
        "doc"   => "application/vnd.ms-word",
        "mxf"   => "application/mxf",
        "oda"   => "application/oda",
        "ogx"   => "application/ogg",
        "pdf"   => "application/pdf",
        "p10"   => "application/pkcs10",
        "ai"    => "application/postscript",
        "eps"   => "application/postscript",
        "ps"    => "application/postscript",
        "rtf"   => "application/rtf",
        "sdp"   => "application/sdp",
        "siv"   => "application/sieve",
        "sieve" => "application/sieve",
        "smil"  => "application/smil",
        "smi"   => "application/smil",
        "sml"   => "application/smil",
        "gram"  => "application/srgs",
        "xml"   => "text/xml",
        "zip"   => "application/x-zip-compressed",
        "xlsx"  => "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
        "docx"  => "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
        726     => "audio/32kadpcm",
        "amr"   => "audio/AMR",
        "at3"   => "audio/ATRAC3",
        "aa3"   => "audio/ATRAC3",
        "omg"   => "audio/ATRAC3",
        "evc"   => "audio/EVRC",
        "evb"   => "audio/EVRCB",
        "evw"   => "audio/EVRCWB",
        "l16"   => "audio/L16",
        "smv"   => "audio/SMV",
        "ac3"   => "audio/ac3",
        "au"    => "audio/basic",
        "snd"   => "audio/basic",
        "dls"   => "audio/dls",
        "lbc"   => "audio/iLBC",
        "mid"   => "audio/midi",
        "midi"  => "audio/midi",
        "kar"   => "audio/midi",
        "mpga"  => "audio/mpeg",
        "mp1"   => "audio/mpeg",
        "mp2"   => "audio/mpeg",
        "mp3"   => "audio/mpeg",
        "oga"   => "audio/ogg",
        "ogg"   => "audio/ogg",
        "spx"   => "audio/ogg",
        "qcp"   => "audio/qcelp",
        "bmp"   => "image/bmp",
        "fits"  => "image/fits",
        "fit"   => "image/fits",
        "fts"   => "image/fits",
        "gif"   => "image/gif",
        "ief"   => "image/ief",
        "jp2"   => "image/jp2",
        "jpg2"  => "image/jp2",
        "jpeg"  => "image/jpeg",
        "jpg"   => "image/jpeg",
        "jpe"   => "image/jpeg",
        "jfif"  => "image/jpeg",
        "jpm"   => "image/jpm",
        "jpgm"  => "image/jpm",
        "jpx"   => "image/jpx",
        "jpf"   => "image/jpx",
        "svg"   => "image/svg+xml",
        "png"   => "image/png",
        "t38"   => "image/t38",
        "tiff"  => "image/tiff",
        "tif"   => "image/tiff",
        "u8msg" => "message/global",
        "eml"   => "message/rfc822",
        "mail"  => "message/rfc822",
        "art"   => "message/rfc822",
        "igs"   => "model/iges",
        "iges"  => "model/iges",
        "msh"   => "model/mesh",
        "mesh"  => "model/mesh",
        "silo"  => "model/mesh",
        "wrl"   => "model/vrml",
        "vrml"  => "model/vrml",
        "ics"   => "text/calendar",
        "ifb"   => "text/calendar",
        "css"   => "text/css",
        "soa"   => "text/dns",
        "zone"  => "text/dns",
        "html"  => "text/html",
        "htm"   => "text/html",
        "js"    => "text/javascript",
        "asc"   => "text/plain",
        "txt"   => "text/plain",
        "text"  => "text/plain",
        "pm"    => "text/plain",
        "el"    => "text/plain",
        "c"     => "text/plain",
        "h"     => "text/plain",
        "cc"    => "text/plain",
        "hh"    => "text/plain",
        "cxx"   => "text/plain",
        "hxx"   => "text/plain",
        "f90"   => "text/plain",
        "rtx"   => "text/richtext",
        "sgml"  => "text/sgml",
        "sgm"   => "text/sgml",
        "3gp"   => "video/3gpp",
        "3gpp"  => "video/3gpp",
        "3g2"   => "video/3gpp2",
        "3gpp2" => "video/3gpp2",
        "mj2"   => "video/mj2",
        "mjp2"  => "video/mj2",
        "mp4"   => "video/mp4",
        "mpg4"  => "video/mp4",
        "mpeg"  => "video/mpeg",
        "mpg"   => "video/mpeg",
        "mpe"   => "video/mpeg",
        "ogv"   => "video/ogg",
        "qt"    => "video/quicktime",
        "mov"   => "video/quicktime",
        "webm"  => "video/webm",
    ]);
}

if (!defined('ryunosuke\\NightDragon\\GLOB_RECURSIVE')) {
    define('ryunosuke\\NightDragon\\GLOB_RECURSIVE', 65536);
}

if (!defined('ryunosuke\\NightDragon\\JSON_MAX_DEPTH')) {
    define('ryunosuke\\NightDragon\\JSON_MAX_DEPTH', -1);
}

if (!defined('ryunosuke\\NightDragon\\JSON_INDENT')) {
    define('ryunosuke\\NightDragon\\JSON_INDENT', -71);
}

if (!defined('ryunosuke\\NightDragon\\JSON_CLOSURE')) {
    define('ryunosuke\\NightDragon\\JSON_CLOSURE', -72);
}

if (!defined('ryunosuke\\NightDragon\\JSON_NEST_LEVEL')) {
    define('ryunosuke\\NightDragon\\JSON_NEST_LEVEL', -73);
}

if (!defined('ryunosuke\\NightDragon\\JSON_INLINE_LEVEL')) {
    define('ryunosuke\\NightDragon\\JSON_INLINE_LEVEL', -74);
}

if (!defined('ryunosuke\\NightDragon\\JSON_INLINE_SCALARLIST')) {
    define('ryunosuke\\NightDragon\\JSON_INLINE_SCALARLIST', -75);
}

if (!defined('ryunosuke\\NightDragon\\JSON_ES5')) {
    define('ryunosuke\\NightDragon\\JSON_ES5', -100);
}

if (!defined('ryunosuke\\NightDragon\\JSON_INT_AS_STRING')) {
    define('ryunosuke\\NightDragon\\JSON_INT_AS_STRING', -101);
}

if (!defined('ryunosuke\\NightDragon\\JSON_FLOAT_AS_STRING')) {
    define('ryunosuke\\NightDragon\\JSON_FLOAT_AS_STRING', -102);
}

if (!defined('ryunosuke\\NightDragon\\JSON_TRAILING_COMMA')) {
    define('ryunosuke\\NightDragon\\JSON_TRAILING_COMMA', -103);
}

if (!defined('ryunosuke\\NightDragon\\JSON_COMMENT_PREFIX')) {
    define('ryunosuke\\NightDragon\\JSON_COMMENT_PREFIX', -104);
}

if (!defined('ryunosuke\\NightDragon\\JSON_TEMPLATE_LITERAL')) {
    define('ryunosuke\\NightDragon\\JSON_TEMPLATE_LITERAL', -105);
}

if (!defined('ryunosuke\\NightDragon\\JSON_BARE_AS_STRING')) {
    define('ryunosuke\\NightDragon\\JSON_BARE_AS_STRING', -106);
}

if (!defined('ryunosuke\\NightDragon\\JSON_OBJECT_HANDLER')) {
    define('ryunosuke\\NightDragon\\JSON_OBJECT_HANDLER', -107);
}

if (!defined('ryunosuke\\NightDragon\\JSON_ESCAPE_SINGLE_QUOTE')) {
    define('ryunosuke\\NightDragon\\JSON_ESCAPE_SINGLE_QUOTE', -108);
}

if (!defined('ryunosuke\\NightDragon\\SI_UNITS')) {
    define('ryunosuke\\NightDragon\\SI_UNITS', [
        -8 => ["y"],
        -7 => ["z"],
        -6 => ["a"],
        -5 => ["f"],
        -4 => ["p"],
        -3 => ["n"],
        -2 => ["u", "μ", "µ"],
        -1 => ["m"],
        0  => [],
        1  => ["k", "K"],
        2  => ["M"],
        3  => ["G"],
        4  => ["T"],
        5  => ["P"],
        6  => ["E"],
        7  => ["Z"],
        8  => ["Y"],
    ]);
}

if (!defined('ryunosuke\\NightDragon\\SORT_STRICT')) {
    define('ryunosuke\\NightDragon\\SORT_STRICT', 256);
}

assert(!function_exists('ryunosuke\\NightDragon\\array_and') || (new \ReflectionFunction('ryunosuke\\NightDragon\\array_and'))->isUserDefined());
if (!function_exists('ryunosuke\\NightDragon\\array_and')) {
    /**
     * 全要素が true になるなら true を返す（1つでも false なら false を返す）
     *
     * $callback が要求するならキーも渡ってくる。
     *
     * Example:
     * ```php
     * that(array_and([true, true]))->isTrue();
     * that(array_and([true, false]))->isFalse();
     * that(array_and([false, false]))->isFalse();
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param iterable $array 対象配列
     * @param ?callable $callback 評価クロージャ。 null なら値そのもので評価
     * @param bool|mixed $default 空配列の場合のデフォルト値
     * @return bool 全要素が true なら true
     */
    function array_and($array, $callback = null, $default = true)
    {
        if (is_empty($array)) {
            return $default;
        }

        $callback = func_user_func_array($callback);

        $n = 0;
        foreach ($array as $k => $v) {
            if (!$callback($v, $k, $n++)) {
                return false;
            }
        }
        return true;
    }
}

assert(!function_exists('ryunosuke\\NightDragon\\array_each') || (new \ReflectionFunction('ryunosuke\\NightDragon\\array_each'))->isUserDefined());
if (!function_exists('ryunosuke\\NightDragon\\array_each')) {
    /**
     * array_reduce の参照版（のようなもの）
     *
     * 配列をループで回し、その途中経過、値、キー、連番をコールバック引数で渡して最終的な結果を返り値として返す。
     * array_reduce と少し似てるが、下記の点が異なる。
     *
     * - いわゆる $carry は返り値で表すのではなく、参照引数で表す
     * - 値だけでなくキー、連番も渡ってくる
     * - 巨大配列の場合でも速度劣化が少ない（array_reduce に巨大配列を渡すと実用にならないレベルで遅くなる）
     *
     * $callback の引数は `($value, $key, $n)` （$n はキーとは関係がない 0 ～ 要素数-1 の通し連番）。
     *
     * 返り値ではなく参照引数なので return する必要はない（ワンライナーが書きやすくなる）。
     * 返り値が空くのでループ制御に用いる。
     * 今のところ $callback が false を返すとそこで break するのみ。
     *
     * 第3引数を省略した場合、**クロージャの第1引数のデフォルト値が使われる**。
     * これは特筆すべき動作で、不格好な第3引数を完全に省略することができる（サンプルコードを参照）。
     * ただし「php の文法違反（今のところエラーにはならないし、全てにデフォルト値をつければ一応回避可能）」「リフレクションを使う（ほんの少し遅くなる）」などの弊害が有るので推奨はしない。
     * （ただ、「意図していることをコードで表す」といった観点ではこの記法の方が正しいとも思う）。
     *
     * Example:
     * ```php
     * // 全要素を文字列的に足し合わせる
     * that(array_each([1, 2, 3, 4, 5], function (&$carry, $v) {$carry .= $v;}, ''))->isSame('12345');
     * // 値をキーにして要素を2乗値にする
     * that(array_each([1, 2, 3, 4, 5], function (&$carry, $v) {$carry[$v] = $v * $v;}, []))->isSame([
     *     1 => 1,
     *     2 => 4,
     *     3 => 9,
     *     4 => 16,
     *     5 => 25,
     * ]);
     * // 上記と同じ。ただし、3 で break する
     * that(array_each([1, 2, 3, 4, 5], function (&$carry, $v, $k){
     *     if ($k === 3) return false;
     *     $carry[$v] = $v * $v;
     * }, []))->isSame([
     *     1 => 1,
     *     2 => 4,
     *     3 => 9,
     * ]);
     *
     * // 下記は完全に同じ（第3引数の代わりにデフォルト引数を使っている）
     * that(array_each([1, 2, 3], function (&$carry = [], $v = null) {
     *         $carry[$v] = $v * $v;
     *     }))->isSame(array_each([1, 2, 3], function (&$carry, $v) {
     *         $carry[$v] = $v * $v;
     *     }, [])
     *     // 個人的に↑のようなぶら下がり引数があまり好きではない（クロージャを最後の引数にしたい）
     * );
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param iterable $array 対象配列
     * @param callable $callback 評価クロージャ。(&$carry, $key, $value) を受ける
     * @param mixed $default ループの最初や空の場合に適用される値
     * @return mixed each した結果
     */
    function array_each($array, $callback, $default = null)
    {
        if (func_num_args() === 2) {
            /** @var \ReflectionFunction $ref */
            $ref = reflect_callable($callback);
            $params = $ref->getParameters();
            if ($params[0]->isDefaultValueAvailable()) {
                $default = $params[0]->getDefaultValue();
            }
        }

        $n = 0;
        foreach ($array as $k => $v) {
            $return = $callback($default, $v, $k, $n++);
            if ($return === false) {
                break;
            }
        }
        return $default;
    }
}

assert(!function_exists('ryunosuke\\NightDragon\\array_explode') || (new \ReflectionFunction('ryunosuke\\NightDragon\\array_explode'))->isUserDefined());
if (!function_exists('ryunosuke\\NightDragon\\array_explode')) {
    /**
     * 配列を指定条件で分割する
     *
     * 文字列の explode を更に一階層掘り下げたイメージ。
     * $condition で指定された要素は結果配列に含まれない。
     *
     * $condition にはクロージャが指定できる。クロージャの場合は true 相当を返した場合に分割要素とみなされる。
     * 引数は (値, キー)の順番。
     *
     * $limit に負数を与えると「その絶対値-1までを結合したものと残り」を返す。
     * 端的に言えば「正数を与えると後詰めでその個数で返す」「負数を与えると前詰めでその（絶対値）個数で返す」という動作になる。
     *
     * Example:
     * ```php
     * // null 要素で分割
     * that(array_explode(['a', null, 'b', 'c'], null))->isSame([['a'], [2 => 'b', 3 => 'c']]);
     * // クロージャで分割（大文字で分割）
     * that(array_explode(['a', 'B', 'c', 'D', 'e'], fn($v) => ctype_upper($v)))->isSame([['a'], [2 => 'c'], [4 => 'e']]);
     * // 負数指定
     * that(array_explode(['a', null, 'b', null, 'c'], null, -2))->isSame([[0 => 'a', 1 => null, 2 => 'b'], [4 => 'c']]);
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param iterable $array 対象配列
     * @param mixed $condition 分割条件
     * @param int $limit 最大分割数
     * @return array 分割された配列
     */
    function array_explode($array, $condition, $limit = \PHP_INT_MAX)
    {
        $array = arrayval($array, false);

        $limit = (int) $limit;
        if ($limit < 0) {
            // キーまで考慮するとかなりややこしくなるので富豪的にやる
            $reverse = array_explode(array_reverse($array, true), $condition, -$limit);
            $reverse = array_map(fn($v) => array_reverse($v, true), $reverse);
            return array_reverse($reverse);
        }
        // explode において 0 は 1 と等しい
        if ($limit === 0) {
            $limit = 1;
        }

        $result = [];
        $chunk = [];
        $n = -1;
        foreach ($array as $k => $v) {
            $n++;

            if ($limit === 1) {
                $chunk = array_slice($array, $n, null, true);
                break;
            }

            if ($condition instanceof \Closure) {
                $match = $condition($v, $k, $n);
            }
            else {
                $match = $condition === $v;
            }

            if ($match) {
                $limit--;
                $result[] = $chunk;
                $chunk = [];
            }
            else {
                $chunk[$k] = $v;
            }
        }
        $result[] = $chunk;
        return $result;
    }
}

assert(!function_exists('ryunosuke\\NightDragon\\array_flatten') || (new \ReflectionFunction('ryunosuke\\NightDragon\\array_flatten'))->isUserDefined());
if (!function_exists('ryunosuke\\NightDragon\\array_flatten')) {
    /**
     * 多階層配列をフラットに展開する
     *
     * 巷にあふれている実装と違って、 ["$pkey.$ckey" => $value] 形式の配列でも返せる。
     * $delimiter で区切り文字を指定した場合にそのようになる。
     * $delimiter = null の場合に本当の配列で返す（巷の実装と同じ）。
     *
     * Example:
     * ```php
     * $array = [
     *    'k1' => 'v1',
     *    'k2' => [
     *        'k21' => 'v21',
     *        'k22' => [
     *            'k221' => 'v221',
     *            'k222' => 'v222',
     *            'k223' => [1, 2, 3],
     *        ],
     *    ],
     * ];
     * // 区切り文字指定なし
     * that(array_flatten($array))->isSame([
     *    0 => 'v1',
     *    1 => 'v21',
     *    2 => 'v221',
     *    3 => 'v222',
     *    4 => 1,
     *    5 => 2,
     *    6 => 3,
     * ]);
     * // 区切り文字指定
     * that(array_flatten($array, '.'))->isSame([
     *    'k1'            => 'v1',
     *    'k2.k21'        => 'v21',
     *    'k2.k22.k221'   => 'v221',
     *    'k2.k22.k222'   => 'v222',
     *    'k2.k22.k223.0' => 1,
     *    'k2.k22.k223.1' => 2,
     *    'k2.k22.k223.2' => 3,
     * ]);
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param iterable $array 対象配列
     * @param string|\Closure|null $delimiter キーの区切り文字。 null を与えると連番になる
     * @return array フラット化された配列
     */
    function array_flatten($array, $delimiter = null)
    {
        $result = [];
        $core = function ($array, $delimiter, $parents) use (&$core, &$result) {
            foreach ($array as $k => $v) {
                $keys = $parents;
                $keys[] = $k;
                if (is_iterable($v)) {
                    $core($v, $delimiter, $keys);
                }
                else {
                    if ($delimiter === null) {
                        $result[] = $v;
                    }
                    elseif ($delimiter instanceof \Closure) {
                        $result[$delimiter($keys)] = $v;
                    }
                    else {
                        $result[implode($delimiter, $keys)] = $v;
                    }
                }
            }
        };

        $core($array, $delimiter, []);
        return $result;
    }
}

assert(!function_exists('ryunosuke\\NightDragon\\array_replace_callback') || (new \ReflectionFunction('ryunosuke\\NightDragon\\array_replace_callback'))->isUserDefined());
if (!function_exists('ryunosuke\\NightDragon\\array_replace_callback')) {
    /**
     * array_replace のコールバック版
     *
     * 基本的なルールは array_replace と全く同じ（連番の扱いや後方優先など）。
     * 値が重複している場合に重複している配列でコールバックが呼ばれる。
     *
     * コールバックの引数は($重複値配列, $そのキー)であり、$重複値配列には重複しなかった配列の値は含まれない。
     * ただし、キーは維持されるので歯抜けになっていたり、あるべきキーが無かったりを調べればどれとどれが重複ししていたの判定が可能。
     * もっとも、普通の使用（2引数の配列）では両方に値が入ってくるという前提で問題ない。
     *
     * Example:
     * ```php
     * $a1 = [
     *     'a' => 'a1',
     *     'b' => 'b1',
     *     'c' => 'c1',
     *     'x' => 'x1',
     * ];
     * $a2 = [
     *     'a' => 'a2',
     *     'b' => 'b2',
     *     'y' => 'y2',
     * ];
     * $a3 = [
     *     'a' => 'a3',
     *     'c' => 'c3',
     *     'z' => 'z3',
     * ];
     * that(array_replace_callback(fn($args, $k) => "$k:" . json_encode($args), $a1, $a2, $a3))->isSame([
     *     "a" => 'a:["a1","a2","a3"]',    // 全てに存在するので3つ全てが渡ってくる
     *     "b" => 'b:["b1","b2"]',         // 1,2 に存在するので2つ渡ってくる
     *     "c" => 'c:{"0":"c1","2":"c3"}', // 1,3 に存在するので2つ渡ってくる（2が歯抜けになる）
     *     "x" => 'x1', // 重複していないのでコールバック自体が呼ばれない
     *     "y" => 'y2', // 重複していないのでコールバック自体が呼ばれない
     *     "z" => 'z3', // 重複していないのでコールバック自体が呼ばれない
     * ]);
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param callable $callback 重複コールバック
     * @param array ...$arrays マージする配列
     * @return array マージされた配列
     */
    function array_replace_callback(callable $callback, array ...$arrays)
    {
        $callback = func_user_func_array($callback);

        // まず普通に呼んで・・・
        $result = array_replace(...$arrays);

        // 重複値をコールバックすれば順番も乱れずシンプルに上書きできる
        foreach ($result as $k => $v) {
            $duplicated = [];
            foreach ($arrays as $n => $array) {
                if (array_key_exists($k, $array)) {
                    $duplicated[$n] = $array[$k];
                }
            }
            if (count($duplicated) > 1) {
                $result[$k] = $callback($duplicated, $k);
            }
        }
        return $result;
    }
}

assert(!function_exists('ryunosuke\\NightDragon\\array_shrink_key') || (new \ReflectionFunction('ryunosuke\\NightDragon\\array_shrink_key'))->isUserDefined());
if (!function_exists('ryunosuke\\NightDragon\\array_shrink_key')) {
    /**
     * 値の優先順位を逆にした array_intersect_key
     *
     * array_intersect_key は「左優先で共通項を取る」という動作だが、この関数は「右優先で共通項を取る」という動作になる。
     * 「配列の並び順はそのままで値だけ変えたい/削ぎ落としたい」という状況はまれによくあるはず。
     *
     * Example:
     * ```php
     * $array1 = ['a' => 'A1', 'b' => 'B1', 'c' => 'C1'];
     * $array2 = ['c' => 'C2', 'b' => 'B2', 'a' => 'A2'];
     * $array3 = ['c' => 'C3', 'dummy' => 'DUMMY'];
     * // 全共通項である 'c' キーのみが生き残り、その値は最後の 'C3' になる
     * that(array_shrink_key($array1, $array2, $array3))->isSame(['c' => 'C3']);
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param iterable|array|object ...$variadic 共通項を取る配列（可変引数）
     * @return array 新しい配列
     */
    function array_shrink_key(...$variadic)
    {
        $result = [];
        foreach ($variadic as $n => $array) {
            if (!is_array($array)) {
                $variadic[$n] = arrayval($array, false);
            }
            $result = array_replace($result, $variadic[$n]);
        }
        return array_intersect_key($result, ...$variadic);
    }
}

assert(!function_exists('ryunosuke\\NightDragon\\array_sprintf') || (new \ReflectionFunction('ryunosuke\\NightDragon\\array_sprintf'))->isUserDefined());
if (!function_exists('ryunosuke\\NightDragon\\array_sprintf')) {
    /**
     * キーと値で sprintf する
     *
     * 配列の各要素を文字列化して返すイメージ。
     * $glue を与えるとさらに implode して返す（返り値が文字列になる）。
     *
     * $format は書式文字列（$v, $k）。
     * callable を与えると sprintf ではなくコールバック処理になる（$v, $k）。
     * 省略（null）するとキーを format 文字列、値を引数として **vsprintf** する。
     *
     * Example:
     * ```php
     * $array = ['key1' => 'val1', 'key2' => 'val2'];
     * // key, value を利用した sprintf
     * that(array_sprintf($array, '%2$s=%1$s'))->isSame(['key1=val1', 'key2=val2']);
     * // 第3引数を与えるとさらに implode される
     * that(array_sprintf($array, '%2$s=%1$s', ' '))->isSame('key1=val1 key2=val2');
     * // クロージャを与えるとコールバック動作になる
     * $closure = fn($v, $k) => "$k=" . strtoupper($v);
     * that(array_sprintf($array, $closure, ' '))->isSame('key1=VAL1 key2=VAL2');
     * // 省略すると vsprintf になる
     * that(array_sprintf([
     *     'str:%s,int:%d' => ['sss', '3.14'],
     *     'single:%s'     => 'str',
     * ], null, '|'))->isSame('str:sss,int:3|single:str');
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param iterable $array 対象配列
     * @param string|callable|null $format 書式文字列あるいはクロージャ
     * @param ?string $glue 結合文字列。未指定時は implode しない
     * @return array|string sprintf された配列
     */
    function array_sprintf($array, $format = null, $glue = null)
    {
        if (is_callable($format)) {
            $callback = func_user_func_array($format);
        }
        elseif ($format === null) {
            $callback = fn($v, $k, $n) => vsprintf($k, is_array($v) ? $v : [$v]);
        }
        else {
            $callback = fn($v, $k, $n) => sprintf($format, $v, $k);
        }

        $result = [];
        $n = 0;
        foreach ($array as $k => $v) {
            $result[] = $callback($v, $k, $n++);
        }

        if ($glue !== null) {
            return implode($glue, $result);
        }

        return $result;
    }
}

assert(!function_exists('ryunosuke\\NightDragon\\arrayize') || (new \ReflectionFunction('ryunosuke\\NightDragon\\arrayize'))->isUserDefined());
if (!function_exists('ryunosuke\\NightDragon\\arrayize')) {
    /**
     * 引数の配列を生成する。
     *
     * 配列以外を渡すと配列化されて追加される。
     * 配列を渡してもそのままだが、連番配列の場合はマージ、連想配列の場合は結合となる。
     * iterable や Traversable は考慮せずあくまで「配列」としてチェックする。
     *
     * Example:
     * ```php
     * // 値は配列化される
     * that(arrayize(1, 2, 3))->isSame([1, 2, 3]);
     * // 配列はそのまま
     * that(arrayize([1], [2], [3]))->isSame([1, 2, 3]);
     * // 連想配列、連番配列の挙動
     * that(arrayize([1, 2, 3], [4, 5, 6], ['a' => 'A1'], ['a' => 'A2']))->isSame([1, 2, 3, 4, 5, 6, 'a' => 'A1']);
     * // stdClass は foreach 可能だがあくまで配列としてチェックする
     * $object = new \stdClass();
     * that(arrayize($object, false, [1, 2, 3]))->isSame([$object, false, 1, 2, 3]);
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param mixed ...$variadic 生成する要素（可変引数）
     * @return array 引数を配列化したもの
     */
    function arrayize(...$variadic)
    {
        $result = [];
        foreach ($variadic as $arg) {
            if (!is_array($arg)) {
                $result[] = $arg;
            }
            elseif ($result && !is_hasharray($arg)) {
                $result = array_merge($result, $arg);
            }
            else {
                // array_merge に合わせるなら $result = $arg + $result で後方上書きの方がいいかも
                // 些細な変更だけど後方互換性が完全に壊れるのでいったん保留（可変引数なんてほとんど使ってないと思うけど…）
                $result += $arg; // for compatible
            }
        }
        return $result;
    }
}

assert(!function_exists('ryunosuke\\NightDragon\\first_keyvalue') || (new \ReflectionFunction('ryunosuke\\NightDragon\\first_keyvalue'))->isUserDefined());
if (!function_exists('ryunosuke\\NightDragon\\first_keyvalue')) {
    /**
     * 配列の最初のキー/値ペアをタプルで返す
     *
     * 空の場合は $default を返す。
     *
     * Example:
     * ```php
     * that(first_keyvalue(['a', 'b', 'c']))->isSame([0, 'a']);
     * that(first_keyvalue([], 999))->isSame(999);
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param iterable|object $array 対象配列
     * @param mixed $default 無かった場合のデフォルト値
     * @return array [最初のキー, 最初の値]
     */
    function first_keyvalue($array, $default = null)
    {
        foreach ($array as $k => $v) {
            return [$k, $v];
        }
        return $default;
    }
}

assert(!function_exists('ryunosuke\\NightDragon\\first_value') || (new \ReflectionFunction('ryunosuke\\NightDragon\\first_value'))->isUserDefined());
if (!function_exists('ryunosuke\\NightDragon\\first_value')) {
    /**
     * 配列の最初の値を返す
     *
     * 空の場合は $default を返す。
     *
     * Example:
     * ```php
     * that(first_value(['a', 'b', 'c']))->isSame('a');
     * that(first_value([], 999))->isSame(999);
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param iterable $array 対象配列
     * @param mixed $default 無かった場合のデフォルト値
     * @return mixed 最初の値
     */
    function first_value($array, $default = null)
    {
        if (is_empty($array)) {
            return $default;
        }
        /** @noinspection PhpUnusedLocalVariableInspection */
        [$k, $v] = first_keyvalue($array);
        return $v;
    }
}

assert(!function_exists('ryunosuke\\NightDragon\\is_hasharray') || (new \ReflectionFunction('ryunosuke\\NightDragon\\is_hasharray'))->isUserDefined());
if (!function_exists('ryunosuke\\NightDragon\\is_hasharray')) {
    /**
     * 配列が連想配列か調べる
     *
     * 空の配列は普通の配列とみなす。
     *
     * Example:
     * ```php
     * that(is_hasharray([]))->isFalse();
     * that(is_hasharray([1, 2, 3]))->isFalse();
     * that(is_hasharray(['x' => 'X']))->isTrue();
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param array $array 調べる配列
     * @return bool 連想配列なら true
     */
    function is_hasharray(array $array)
    {
        if (function_exists('array_is_list')) {
            return !array_is_list($array); // @codeCoverageIgnore
        }

        $i = 0;
        foreach ($array as $k => $dummy) {
            if ($k !== $i++) {
                return true;
            }
        }
        return false;
    }
}

assert(!function_exists('ryunosuke\\NightDragon\\const_exists') || (new \ReflectionFunction('ryunosuke\\NightDragon\\const_exists'))->isUserDefined());
if (!function_exists('ryunosuke\\NightDragon\\const_exists')) {
    /**
     * クラス定数が存在するか調べる
     *
     * グローバル定数も調べられる。ので実質的には defined とほぼ同じで違いは下記。
     *
     * - defined は単一引数しか与えられないが、この関数は2つの引数も受け入れる
     * - defined は private const で即死するが、この関数はきちんと調べることができる
     * - ClassName::class は常に true を返す
     *
     * あくまで存在を調べるだけで実際にアクセスできるかは分からないので注意（`property_exists` と同じ）。
     *
     * Example:
     * ```php
     * // クラス定数が調べられる（1引数、2引数どちらでも良い）
     * that(const_exists('ArrayObject::STD_PROP_LIST'))->isTrue();
     * that(const_exists('ArrayObject', 'STD_PROP_LIST'))->isTrue();
     * that(const_exists('ArrayObject::UNDEFINED'))->isFalse();
     * that(const_exists('ArrayObject', 'UNDEFINED'))->isFalse();
     * // グローバル（名前空間）もいける
     * that(const_exists('PHP_VERSION'))->isTrue();
     * that(const_exists('UNDEFINED'))->isFalse();
     * ```
     *
     * @package ryunosuke\Functions\Package\classobj
     *
     * @param string|object $classname 調べるクラス
     * @param string $constname 調べるクラス定数
     * @return bool 定数が存在するなら true
     */
    function const_exists($classname, $constname = '')
    {
        $colonp = strpos($classname, '::');
        if ($colonp === false && strlen($constname) === 0) {
            return defined($classname);
        }
        if (strlen($constname) === 0) {
            $constname = substr($classname, $colonp + 2);
            $classname = substr($classname, 0, $colonp);
        }

        try {
            $refclass = new \ReflectionClass($classname);
            if (strcasecmp($constname, 'class') === 0) {
                return true;
            }
            return $refclass->hasConstant($constname);
        }
        catch (\Throwable) {
            return false;
        }
    }
}

assert(!function_exists('ryunosuke\\NightDragon\\object_properties') || (new \ReflectionFunction('ryunosuke\\NightDragon\\object_properties'))->isUserDefined());
if (!function_exists('ryunosuke\\NightDragon\\object_properties')) {
    /**
     * オブジェクトのプロパティを可視・不可視を問わず取得する
     *
     * get_object_vars + no public プロパティを返すイメージ。
     * クロージャだけは特別扱いで this + use 変数を返す。
     *
     * Example:
     * ```php
     * $object = new #[\AllowDynamicProperties] class('something', 42) extends \Exception{};
     * $object->oreore = 'oreore';
     *
     * // get_object_vars はそのスコープから見えないプロパティを取得できない
     * // var_dump(get_object_vars($object));
     *
     * // array キャストは全て得られるが null 文字を含むので扱いにくい
     * // var_dump((array) $object);
     *
     * // この関数を使えば不可視プロパティも取得できる
     * that(object_properties($object))->subsetEquals([
     *     'message' => 'something',
     *     'code'    => 42,
     *     'oreore'  => 'oreore',
     * ]);
     *
     * // クロージャは this と use 変数を返す
     * that(object_properties(fn() => $object))->is([
     *     'this'   => $this,
     *     'object' => $object,
     * ]);
     * ```
     *
     * @package ryunosuke\Functions\Package\classobj
     *
     * @param object $object オブジェクト
     * @param array $privates 継承ツリー上の private が格納される
     * @return array 全プロパティの配列
     */
    function object_properties($object, &$privates = [])
    {
        if ($object instanceof \Closure) {
            $ref = new \ReflectionFunction($object);
            $uses = method_exists($ref, 'getClosureUsedVariables') ? $ref->getClosureUsedVariables() : $ref->getStaticVariables();
            return ['this' => $ref->getClosureThis()] + $uses;
        }

        $fields = [];
        foreach ((array) $object as $name => $field) {
            $cname = '';
            $names = explode("\0", $name);
            if (count($names) > 1) {
                $name = array_pop($names);
                $cname = $names[1];
            }
            $fields[$cname][$name] = $field;
        }

        $classname = get_class($object);
        $parents = array_values(['', '*', $classname] + class_parents($object));
        uksort($fields, function ($a, $b) use ($parents) {
            return array_search($a, $parents, true) <=> array_search($b, $parents, true);
        });

        $result = [];
        foreach ($fields as $cname => $props) {
            foreach ($props as $name => $field) {
                if ($cname !== '' && $cname !== '*' && $classname !== $cname) {
                    $privates[$cname][$name] = $field;
                }
                if (!array_key_exists($name, $result)) {
                    $result[$name] = $field;
                }
            }
        }

        return $result;
    }
}

assert(!function_exists('ryunosuke\\NightDragon\\type_exists') || (new \ReflectionFunction('ryunosuke\\NightDragon\\type_exists'))->isUserDefined());
if (!function_exists('ryunosuke\\NightDragon\\type_exists')) {
    /**
     * 型が存在するか返す
     *
     * class/interface/trait/enum exists の合せ技。
     * trait/enum のように今後型的なものがさらに増えるかもしれないし、class_exists だけして interface/trait が抜けているコードを何度も見てきた。
     * それを一元管理するような関数となる。
     *
     * Example:
     * ```php
     * that(class_exists(\Throwable::class))->isFalse();     // class_exists は class にしか反応しない
     * that(interface_exists(\Exception::class))->isFalse(); // interface_exists は interface にしか反応しない
     * that(trait_exists(\Error::class))->isFalse();         // trait_exists は trait にしか反応しない
     * // type_exists であれば全てに反応する
     * that(type_exists(\Throwable::class))->isTrue();
     * that(type_exists(\Exception::class))->isTrue();
     * that(type_exists(\Error::class))->isTrue();
     * ```
     *
     * @package ryunosuke\Functions\Package\classobj
     *
     * @param string $typename 調べる型名
     * @param bool $autoload オートロードを行うか
     * @return bool 型が存在するなら true
     */
    function type_exists($typename, $autoload = true)
    {
        if (class_exists($typename, $autoload)) {
            return true;
        }
        if (interface_exists($typename, $autoload)) {
            return true;
        }
        if (trait_exists($typename, $autoload)) {
            return true;
        }
        // enum は class で実装されているので enum_exists は不要
        return false;
    }
}

assert(!function_exists('ryunosuke\\NightDragon\\html_strip') || (new \ReflectionFunction('ryunosuke\\NightDragon\\html_strip'))->isUserDefined());
if (!function_exists('ryunosuke\\NightDragon\\html_strip')) {
    /**
     * html の空白類を除去して minify する
     *
     * 文字列的ではなく DOM 的に行うのでおかしな部分 html を食わせると意図しない結果になる可能性がある。
     * その副作用として属性のクオートやタグ内空白は全て正規化される。
     *
     * html コメントも削除される。
     * また、空白が意味を持つタグ（textarea, pre）は対象にならない。
     * さらに、php を含むような html （テンプレート）の php タグは一切の対象外となる。
     *
     * これらの挙動の一部はオプションで指定が可能。
     *
     * Example:
     * ```php
     * // e.g. id が " でクオートされている
     * // e.g. class のクオートが " になっている
     * // e.g. タグ内空白（id, class の間隔等）がスペース1つになっている
     * // e.g. php タグは一切変更されていない
     * // e.g. textarea は保持されている
     * that(html_strip("<span  id=id  class='c1  c2  c3'><?= '<hoge>  </hoge>' ?> a  b  c </span> <pre> a  b  c </pre>"))->isSame('<span id="id" class="c1  c2  c3"><?= \'<hoge>  </hoge>\' ?> a b c </span><pre> a  b  c </pre>');
     * ```
     *
     * @package ryunosuke\Functions\Package\dataformat
     *
     * @param string $html html 文字列
     * @param array $options オプション配列
     * @return string 空白除去された html 文字列
     */
    function html_strip($html, $options = [])
    {
        $options += [
            'error-level'    => E_USER_ERROR, // エラー時の報告レベル
            'encoding'       => 'UTF-8',      // html のエンコーディング
            'escape-phpcode' => true,         // php タグを退避するか
            'html-comment'   => true,         // html コメントも対象にするか
            'ignore-tags'    => [
                // 空白を除去しない特別タグ
                'pre',      // html の仕様でそのまま表示
                'textarea', // html の仕様...なのかスタイルなのかは分からないが普通はそのまま表示だろう
                'script',   // type が js とは限らない。そもそも js だとしても下手にいじるのは怖すぎる
                'style',    // 同上
            ],
        ];

        $preserving = unique_string($html, 64, range('a', 'z'));
        $mapping = [];

        if ($options['escape-phpcode']) {
            $mapping = [];
            $html = php_strip($html, [
                'replacer'       => $preserving,
                'trailing_break' => false,
            ], $mapping);
        }

        // xml 宣言がないとマルチバイト文字が html エンティティになってしまうし documentElement がないと <p> が自動付与されてしまう
        $docTag = "root-$preserving";
        $mapping["<$docTag>"] = '';
        $mapping["</$docTag>"] = '';
        $html = "<?xml encoding=\"{$options['encoding']}\"><$docTag>$html</$docTag>";

        // dom 化
        libxml_clear_errors();
        $current = libxml_use_internal_errors(true);
        $dom = new \DOMDocument();
        $dom->loadHTML($html, LIBXML_HTML_NOIMPLIED | LIBXML_HTML_NODEFDTD | LIBXML_NOXMLDECL);
        if ($options['error-level']) {
            // http://www.xmlsoft.org/html/libxml-xmlerror.html
            $nohandling = [];
            $nohandling[] = 801;
            if (!$options['escape-phpcode']) {
                $nohandling[] = 46;
            }
            foreach (libxml_get_errors() as $error) {
                if (!in_array($error->code, $nohandling, true)) {
                    trigger_error($error->code . ': ' . $error->message, $options['error-level']);
                }
            }
        }
        libxml_use_internal_errors($current);

        $xpath = new \DOMXPath($dom);

        if ($options['html-comment']) {
            /** @var \DOMComment[] $comments */
            $comments = iterator_to_array($xpath->query('//comment()'), true);
            foreach ($comments as $comment) {
                $comment->parentNode->removeChild($comment);
            }
            $dom->documentElement->normalize();
        }

        /** @var \DOMText[] $texts */
        $texts = iterator_to_array($xpath->query('//text()'), true);
        $texts = array_values(array_filter($texts, function (\DOMNode $node) use ($options) {
            while ($node = $node->parentNode) {
                if (in_array($node->nodeName, $options['ignore-tags'], true)) {
                    return false;
                }
            }
            return true;
        }));
        // @see https://developer.mozilla.org/ja/docs/Web/API/Document_Object_Model/Whitespace
        foreach ($texts as $n => $text) {
            // 連続空白の正規化
            $text->data = preg_replace("#[\t\n\r ]+#u", " ", $text->data);

            // 空白の直後に他の空白がある場合は (2 つが別々なインライン要素をまたぐ場合も含めて) 無視
            if (($next = $texts[$n + 1] ?? null) && ($text->data[-1] ?? null) === ' ') {
                $next->data = ltrim($next->data, "\t\n\r ");
            }

            // 行頭と行末の一連の空白が削除される
            $prev = $text->previousSibling ?? $text->parentNode->previousSibling;
            if (!$prev || in_array($prev->nodeName, $options['ignore-tags'], true)) {
                $text->data = ltrim($text->data, "\t\n\r ");
            }
            $next = $text->nextSibling ?? $text->parentNode->nextSibling;
            if (!$next || in_array($next->nodeName, $options['ignore-tags'], true)) {
                $text->data = rtrim($text->data, "\t\n\r ");
            }
        }
        return trim(strtr($dom->saveHTML($dom->documentElement), $mapping), "\t\n\r ");
    }
}

assert(!function_exists('ryunosuke\\NightDragon\\file_rewrite_contents') || (new \ReflectionFunction('ryunosuke\\NightDragon\\file_rewrite_contents'))->isUserDefined());
if (!function_exists('ryunosuke\\NightDragon\\file_rewrite_contents')) {
    /**
     * ファイルを読み込んで内容をコールバックに渡して書き込む
     *
     * Example:
     * ```php
     * // 適当にファイルを用意
     * $testpath = sys_get_temp_dir() . '/rewrite.txt';
     * file_put_contents($testpath, 'hoge');
     * // 前後に 'pre-', '-fix' を付与する
     * file_rewrite_contents($testpath, fn($contents, $fp) => "pre-$contents-fix");
     * that($testpath)->fileEquals('pre-hoge-fix');
     * ```
     *
     * @package ryunosuke\Functions\Package\filesystem
     *
     * @param string $filename 読み書きするファイル名
     * @param callable $callback 書き込む内容。引数で $contents, $fp が渡ってくる
     * @param int $operation ロック定数（LOCL_SH, LOCK_EX, LOCK_NB）
     * @return int 書き込まれたバイト数
     */
    function file_rewrite_contents($filename, $callback, $operation = 0)
    {
        /** @var resource $fp */
        try {
            // 開いて
            $fp = fopen($filename, 'c+b') ?: throw new \UnexpectedValueException('failed to fopen.');
            if ($operation) {
                flock($fp, $operation) ?: throw new \UnexpectedValueException('failed to flock.');
            }

            // 読み込んで
            rewind($fp) ?: throw new \UnexpectedValueException('failed to rewind.');
            $contents = false !== ($t = stream_get_contents($fp)) ? $t : throw new \UnexpectedValueException('failed to stream_get_contents.');

            // 変更して
            rewind($fp) ?: throw new \UnexpectedValueException('failed to rewind.');
            ftruncate($fp, 0) ?: throw new \UnexpectedValueException('failed to ftruncate.');
            $contents = $callback($contents, $fp);

            // 書き込んで
            $return = ($r = fwrite($fp, $contents)) !== false ? $r : throw new \UnexpectedValueException('failed to fwrite.');
            fflush($fp) ?: throw new \UnexpectedValueException('failed to fflush.');

            // 閉じて
            if ($operation) {
                flock($fp, LOCK_UN) ?: throw new \UnexpectedValueException('failed to flock.');
            }
            fclose($fp) ?: throw new \UnexpectedValueException('failed to fclose.');

            // 返す
            return $return;
        }
        catch (\Exception $ex) {
            if (isset($fp)) {
                if ($operation) {
                    flock($fp, LOCK_UN);
                }
                fclose($fp);
            }
            throw $ex;
        }
    }
}

assert(!function_exists('ryunosuke\\NightDragon\\file_set_contents') || (new \ReflectionFunction('ryunosuke\\NightDragon\\file_set_contents'))->isUserDefined());
if (!function_exists('ryunosuke\\NightDragon\\file_set_contents')) {
    /**
     * ディレクトリも掘る file_put_contents
     *
     * 書き込みは一時ファイルと rename を使用してアトミックに行われる。
     *
     * Example:
     * ```php
     * file_set_contents(sys_get_temp_dir() . '/not/filename.ext', 'hoge');
     * that(file_get_contents(sys_get_temp_dir() . '/not/filename.ext'))->isSame('hoge');
     * ```
     *
     * @package ryunosuke\Functions\Package\filesystem
     *
     * @param string $filename 書き込むファイル名
     * @param string $data 書き込む内容
     * @param int $umask ディレクトリを掘る際の umask
     * @return ?int 書き込まれたバイト数
     */
    function file_set_contents($filename, $data, $umask = 0002)
    {
        if (func_num_args() === 2) {
            $umask = umask();
        }

        $filename = path_normalize($filename);

        if (!is_dir($dirname = dirname($filename))) {
            if (!@mkdir_p($dirname, $umask)) {
                throw new \RuntimeException("failed to mkdir($dirname)");
            }
        }

        error_clear_last();
        $tempnam = @tempnam($dirname, 'tmp');
        if (strpos(error_get_last()['message'] ?? '', "file created in the system's temporary directory") !== false) {
            $result = file_put_contents($filename, $data);
            @chmod($filename, 0666 & ~$umask);
            return $result === false ? null : $result;
        }
        if (($result = file_put_contents($tempnam, $data)) !== false) {
            if (rename($tempnam, $filename)) {
                @chmod($filename, 0666 & ~$umask);
                return $result === false ? null : $result;
            }
            unlink($tempnam);
        }
        return null;
    }
}

assert(!function_exists('ryunosuke\\NightDragon\\mkdir_p') || (new \ReflectionFunction('ryunosuke\\NightDragon\\mkdir_p'))->isUserDefined());
if (!function_exists('ryunosuke\\NightDragon\\mkdir_p')) {
    /**
     * ディレクトリを再帰的に掘る
     *
     * 既に存在する場合は何もしない（エラーも出さない）。
     *
     * @package ryunosuke\Functions\Package\filesystem
     *
     * @param string $dirname ディレクトリ名
     * @param int $umask ディレクトリを掘る際の umask
     * @return bool 作成したら true
     */
    function mkdir_p($dirname, $umask = 0002)
    {
        if (func_num_args() === 1) {
            $umask = umask();
        }

        if (file_exists($dirname)) {
            return false;
        }

        return mkdir($dirname, 0777 & (~$umask), true);
    }
}

assert(!function_exists('ryunosuke\\NightDragon\\path_is_absolute') || (new \ReflectionFunction('ryunosuke\\NightDragon\\path_is_absolute'))->isUserDefined());
if (!function_exists('ryunosuke\\NightDragon\\path_is_absolute')) {
    /**
     * パスが絶対パスか判定する
     *
     * Example:
     * ```php
     * that(path_is_absolute('/absolute/path'))->isTrue();
     * that(path_is_absolute('relative/path'))->isFalse();
     * // Windows 環境では下記も true になる
     * if (DIRECTORY_SEPARATOR === '\\') {
     *     that(path_is_absolute('\\absolute\\path'))->isTrue();
     *     that(path_is_absolute('C:\\absolute\\path'))->isTrue();
     * }
     * ```
     *
     * @package ryunosuke\Functions\Package\filesystem
     *
     * @param string $path パス文字列
     * @return bool 絶対パスなら true
     */
    function path_is_absolute($path)
    {
        // スキームが付いている場合は path 部分で判定
        $parts = parse_url($path);
        if (isset($parts['scheme'], $parts['path'])) {
            $path = $parts['path'];
        }
        elseif (isset($parts['scheme'], $parts['host'])) {
            $path = $parts['host'];
        }

        if (substr($path, 0, 1) === '/') {
            return true;
        }

        if (DIRECTORY_SEPARATOR === '\\') {
            if (preg_match('#^([a-z]+:(\\\\|/|$)|\\\\)#i', $path) !== 0) {
                return true;
            }
        }

        return false;
    }
}

assert(!function_exists('ryunosuke\\NightDragon\\path_normalize') || (new \ReflectionFunction('ryunosuke\\NightDragon\\path_normalize'))->isUserDefined());
if (!function_exists('ryunosuke\\NightDragon\\path_normalize')) {
    /**
     * パスを正規化する
     *
     * 具体的には ./ や ../ を取り除いたり連続したディレクトリ区切りをまとめたりする。
     * realpath ではない。のでシンボリックリンクの解決などはしない。その代わりファイルが存在しなくても使用することができる。
     *
     * Example:
     * ```php
     * $DS = DIRECTORY_SEPARATOR;
     * that(path_normalize('/path/to/something'))->isSame("{$DS}path{$DS}to{$DS}something");
     * that(path_normalize('/path/through/../something'))->isSame("{$DS}path{$DS}something");
     * that(path_normalize('./path/current/./through/../something'))->isSame("path{$DS}current{$DS}something");
     * ```
     *
     * @package ryunosuke\Functions\Package\filesystem
     *
     * @param string $path パス文字列
     * @return string 正規化されたパス
     */
    function path_normalize($path)
    {
        $DS = DIRECTORY_SEPARATOR;

        // スキームの保護
        $with_scheme = false;
        $scheme = parse_url($path, PHP_URL_SCHEME);
        if (!($scheme === null || $scheme === 'file') && substr($path, strlen($scheme), 3) === '://') {
            $path = substr($path, strlen($scheme) + 3);
            $DS = '/';
            $with_scheme = true;
        }

        $delimiter = '/';
        if ($DS === '\\') {
            $delimiter .= '\\\\';
        }

        $result = [];
        foreach (preg_split("#[$delimiter]+#u", $path) as $part) {
            if ($part === '.') {
                continue;
            }
            if ($part === '..') {
                if (empty($result)) {
                    throw new \InvalidArgumentException("'$path' is invalid as path string.");
                }
                array_pop($result);
                continue;
            }
            $result[] = $part;
        }
        if (count($result) > 2 && $result[count($result) - 1] === '') {
            array_pop($result);
        }

        $path = implode($DS, $result);

        if ($with_scheme) {
            $path = "$scheme://$path";
        }

        return $path;
    }
}

assert(!function_exists('ryunosuke\\NightDragon\\func_user_func_array') || (new \ReflectionFunction('ryunosuke\\NightDragon\\func_user_func_array'))->isUserDefined());
if (!function_exists('ryunosuke\\NightDragon\\func_user_func_array')) {
    /**
     * パラメータ定義数に応じて呼び出し引数を可変にしてコールする
     *
     * デフォルト引数はカウントされない。必須パラメータの数で呼び出す。
     *
     * $callback に null を与えると例外的に「第1引数を返すクロージャ」を返す。
     *
     * php の標準関数は定義数より多い引数を投げるとエラーを出すのでそれを抑制したい場合に使う。
     *
     * Example:
     * ```php
     * // strlen に2つの引数を渡してもエラーにならない
     * $strlen = func_user_func_array('strlen');
     * that($strlen('abc', null))->isSame(3);
     * ```
     *
     * @package ryunosuke\Functions\Package\funchand
     *
     * @param callable|null $callback 呼び出すクロージャ
     * @return callable 引数ぴったりで呼び出すクロージャ
     */
    function func_user_func_array($callback)
    {
        // null は第1引数を返す特殊仕様
        if ($callback === null) {
            return fn($v) => $v;
        }
        // クロージャはユーザ定義しかありえないので調べる必要がない
        if ($callback instanceof \Closure) {
            // と思ったが、\Closure::fromCallable で作成されたクロージャは内部属性が伝播されるようなので除外
            if (reflect_callable($callback)->isUserDefined()) {
                return $callback;
            }
        }

        // 上記以外は「引数ぴったりで削ぎ落としてコールするクロージャ」を返す
        $plength = parameter_length($callback, true, true);
        return function (...$args) use ($callback, $plength) {
            if (is_infinite($plength)) {
                return $callback(...$args);
            }
            return $callback(...array_slice($args, 0, $plength));
        };
    }
}

assert(!function_exists('ryunosuke\\NightDragon\\is_bindable_closure') || (new \ReflectionFunction('ryunosuke\\NightDragon\\is_bindable_closure'))->isUserDefined());
if (!function_exists('ryunosuke\\NightDragon\\is_bindable_closure')) {
    /**
     * $this を bind 可能なクロージャか調べる
     *
     * Example:
     * ```php
     * that(is_bindable_closure(function () {}))->isTrue();
     * that(is_bindable_closure(static function () {}))->isFalse();
     * ```
     *
     * @package ryunosuke\Functions\Package\funchand
     *
     * @param \Closure $closure 調べるクロージャ
     * @return bool $this を bind 可能なクロージャなら true
     */
    function is_bindable_closure(\Closure $closure)
    {
        return !!@$closure->bindTo(new \stdClass());
    }
}

assert(!function_exists('ryunosuke\\NightDragon\\is_callback') || (new \ReflectionFunction('ryunosuke\\NightDragon\\is_callback'))->isUserDefined());
if (!function_exists('ryunosuke\\NightDragon\\is_callback')) {
    /**
     * callable のうち、関数文字列を false で返す
     *
     * 歴史的な経緯で php の callable は多岐に渡る。
     *
     * 1. 単純なコールバック: `"strtolower"`
     * 2. staticメソッドのコール: `["ClassName", "method"]`
     * 3. オブジェクトメソッドのコール: `[$object, "method"]`
     * 4. staticメソッドのコール: `"ClassName::method"`
     * 5. 相対指定によるstaticメソッドのコール: `["ClassName", "parent::method"]`
     * 6. __invoke実装オブジェクト: `$object`
     * 7. クロージャ: `fn() => something()`
     *
     * 上記のうち 1 を callable とはみなさず false を返す。
     * 現代的には `Closure::fromCallable`, `$object->method(...)` などで callable == Closure という概念が浸透しているが、そうでないこともある。
     * 本ライブラリでも `preg_splice` や `array_sprintf` などで頻出しているので関数として定義する。
     *
     * 副作用はなく、クラスのロードや関数の存在チェックなどは行わない。あくまで型と形式で判定する。
     * 引数は callable でなくても構わない。その場合単に false を返す。
     *
     * @package ryunosuke\Functions\Package\funchand
     *
     * @param mixed $callable 対象 callable
     * @return bool 関数呼び出しの callable なら false
     */
    function is_callback($callable)
    {
        // 大前提（不要に思えるが invoke や配列 [1, 2, 3] などを考慮すると必要）
        if (!is_callable($callable, true)) {
            return false;
        }

        // 変なオブジェクト・配列は↑で除かれている
        if (is_object($callable) || is_array($callable)) {
            return true;
        }

        // 文字列で :: を含んだら関数呼び出しではない
        if (is_string($callable) && strpos($callable, '::') !== false) {
            return true;
        }

        return false;
    }
}

assert(!function_exists('ryunosuke\\NightDragon\\namespace_parse') || (new \ReflectionFunction('ryunosuke\\NightDragon\\namespace_parse'))->isUserDefined());
if (!function_exists('ryunosuke\\NightDragon\\namespace_parse')) {
    /**
     * php ファイルをパースして名前空間配列を返す
     *
     * ファイル内で use/use const/use function していたり、シンボルを定義していたりする箇所を検出して名前空間単位で返す。
     * クラスコンテキストでの解決できないシンボルはその名前空間として返す。
     * つまり、 use せずに いきなり new Hoge() などとしてもその同一名前空間の Hoge として返す。
     * これは同一名前空間であれば use せずとも使用できる php の仕様に合わせるため。
     * 対象はクラスのみであり、定数・関数は対象外。
     * use せずに hoge_function() などとしても、それが同一名前空間なのかグローバルにフォールバックされるのかは静的には決して分からないため。
     *
     * その他、#[AttributeName]や ClassName::class など、おおよそクラス名が必要とされるコンテキストでのシンボルは全て返される。
     *
     * Example:
     * ```php
     * // このような php ファイルをパースすると・・・
     * file_set_contents(sys_get_temp_dir() . '/namespace.php', '
     * <?php
     * namespace NS1;
     * use ArrayObject as AO;
     * use function strlen as SL;
     * function InnerFunc(){}
     * class InnerClass{}
     * define("OUTER\\\\CONST", "OuterConst");
     *
     * namespace NS2;
     * use RuntimeException as RE;
     * use const COUNT_RECURSIVE as CR;
     * class InnerClass{}
     * const InnerConst = 123;
     *
     * // いきなり Hoge を new してみる
     * new Hoge();
     * ');
     * // このような名前空間配列が得られる
     * that(namespace_parse(sys_get_temp_dir() . '/namespace.php'))->isSame([
     *     'NS1' => [
     *         'const'    => [],
     *         'function' => [
     *             'SL'        => 'strlen',
     *             'InnerFunc' => 'NS1\\InnerFunc',
     *         ],
     *         'alias'    => [
     *             'AO'         => 'ArrayObject',
     *             'InnerClass' => 'NS1\\InnerClass',
     *         ],
     *     ],
     *     'OUTER' => [
     *         'const'    => [
     *             'CONST' => 'OUTER\\CONST',
     *         ],
     *         'function' => [],
     *         'alias'    => [],
     *     ],
     *     'NS2' => [
     *         'const'    => [
     *             'CR'         => 'COUNT_RECURSIVE',
     *             'InnerConst' => 'NS2\\InnerConst',
     *         ],
     *         'function' => [],
     *         'alias'    => [
     *             'RE'         => 'RuntimeException',
     *             'InnerClass' => 'NS2\\InnerClass',
     *             'Hoge'       => 'NS2\\Hoge', // 同一名前空間として返される
     *         ],
     *     ],
     * ]);
     * ```
     *
     * @package ryunosuke\Functions\Package\misc
     *
     * @param string $filename ファイル名
     * @param array $options オプション配列
     * @return array 名前空間配列
     */
    function namespace_parse($filename, $options = [])
    {
        $filename = realpath($filename);
        $filemtime = filemtime($filename);
        $options += [
            'cache' => null,
        ];

        $storage = json_storage(__FUNCTION__);

        $storage['mtime'] ??= $filemtime;
        $options['cache'] ??= $storage['mtime'] >= $filemtime;
        if (!$options['cache']) {
            unset($storage['mtime']);
            unset($storage[$filename]);
        }
        return $storage[$filename] ??= (function () use ($filename) {
            $namespace = '';
            $classend = null;

            $tokens = php_tokens(file_get_contents($filename));
            $token = $tokens[0];

            $T_ENUM = defined('T_ENUM') ? T_ENUM : -1; // for compatible
            $result = [];
            while (true) {
                $token = $token->next(["define", T_NAMESPACE, T_USE, T_CONST, T_FUNCTION, T_CLASS, T_INTERFACE, T_TRAIT, $T_ENUM, T_EXTENDS, T_IMPLEMENTS, T_ATTRIBUTE, T_NAME_QUALIFIED, T_STRING]);
                if ($token === null) {
                    break;
                }
                if ($classend !== null && $token->index >= $classend) {
                    $classend = null;
                }

                // define は現在の名前空間とは無関係に名前空間定数を宣言することができる
                if ($token->is(T_STRING) && $token->is("define")) {
                    // ただし実行されないと定義されないので class 内は無視
                    if ($classend !== null) {
                        continue;
                    }

                    // しかも変数が使えたりして静的には決まらないので "" or '' のみとする
                    $token = $token->next([T_CONSTANT_ENCAPSED_STRING, ',']);
                    if ($token->is(T_CONSTANT_ENCAPSED_STRING)) {
                        $define = trim(stripslashes(substr($token, 1, -1)), '\\');
                        [$ns, $nm] = namespace_split($define);
                        $result[$ns] ??= [
                            'const'    => [],
                            'function' => [],
                            'alias'    => [],
                        ];
                        $result[$ns]['const'][$nm] = $define;
                    }
                }
                // 識別子。多岐に渡るので文脈を見て無視しなければならない
                if ($token->is(T_STRING)) {
                    if ($token->prev()->is([
                        T_OBJECT_OPERATOR,          // $object->member
                        T_NULLSAFE_OBJECT_OPERATOR, // $object?->member
                        T_CONST,                    // const CONST = 'dummy'
                        T_GOTO,                     // goto LABEL
                    ])) {
                        continue;
                    }
                    // hoge_function(named: $argument)
                    if ($token->next()->is(':')) {
                        continue;
                    }
                    // hoge_function()
                    if (!$token->prev()->is(T_NEW) && $token->next()->is('(')) {
                        continue;
                    }
                    if ($token->is([
                        // typehint
                        ...['never', 'void', 'null', 'false', 'true', 'bool', 'int', 'float', 'string', 'object', 'iterable', 'mixed'],
                        // specials
                        ...['self', 'static', 'parent'],
                    ])) {
                        continue;
                    }
                    if (defined($token->text)) {
                        continue;
                    }

                    if (false
                        || $token->prev()->is(T_NEW)           // new ClassName
                        || $token->prev()->is(':')             // function method(): ClassName
                        || $token->next()->is(T_VARIABLE)      // ClassName $argument
                        || $token->next()->is(T_DOUBLE_COLON)  // ClassName::CONSTANT
                    ) {
                        $result[$namespace]['alias'][$token->text] ??= concat($namespace, '\\') . $token->text;
                    }
                }
                // T_STRING とほぼ同じ（修飾版）。T_NAME_QUALIFIED である時点で Space\Name であることはほぼ確定だがいくつか除外するものがある
                if ($token->is(T_NAME_QUALIFIED)) {
                    // hoge_function()
                    if (!$token->prev()->is(T_NEW) && $token->next()->is('(')) {
                        continue;
                    }
                    // 最近の php は標準でも名前空間を持つものがあるので除外しておく
                    if (defined($token->text)) {
                        continue;
                    }
                    $result[$namespace]['alias'][$token->text] ??= concat($namespace, '\\') . $token->text;
                }
                if ($token->is(T_NAMESPACE)) {
                    $token = $token->next();
                    $namespace = $token->text;
                    $result[$namespace] = [
                        'const'    => [],
                        'function' => [],
                        'alias'    => [],
                    ];
                }
                if ($token->is(T_USE)) {
                    // function () **use** ($var) {...}
                    if ($token->prev()?->is(')')) {
                        continue;
                    }
                    // class {**use** Trait;}
                    if ($classend !== null) {
                        while (!$token->is(['{', ';'])) {
                            $token = $token->next(['{', ';', ',']);
                            if (!$token->prev()->is(T_NAME_FULLY_QUALIFIED)) {
                                $result[$namespace]['alias'][$token->prev()->text] ??= concat($namespace, '\\') . $token->prev()->text;
                            }
                        }
                        continue;
                    }

                    $next = $token->next();
                    $key = 'alias';
                    if ($next->is(T_CONST)) {
                        $key = 'const';
                        $token = $next;
                    }
                    if ($next->is(T_FUNCTION)) {
                        $key = 'function';
                        $token = $next;
                    }

                    $token = $token->next();
                    $qualified = trim($token->text, '\\');

                    $next = $token->next();
                    if ($next->is(T_NS_SEPARATOR)) {
                        while (!$token->is('}')) {
                            $token = $token->next(['}', ',', T_AS]);
                            if ($token->is(T_AS)) {
                                $qualified2 = $qualified . "\\" . $token->prev()->text;
                                $result[$namespace][$key][$token->next()->text] = $qualified2;
                                $token = $token->next()->next();
                            }
                            else {
                                $qualified2 = $qualified . "\\" . $token->prev()->text;
                                $result[$namespace][$key][namespace_split($qualified2)[1]] = $qualified2;
                            }
                        }
                    }
                    elseif ($next->is(T_AS)) {
                        $token = $next->next();
                        $result[$namespace][$key][$token->text] = $qualified;
                    }
                    else {
                        $result[$namespace][$key][namespace_split($qualified)[1]] = $qualified;
                    }
                }
                if ($token->is([T_CLASS, T_TRAIT, T_INTERFACE, $T_ENUM])) {
                    // class ClassName {...}, $anonymous = new class() {...}
                    if ($token->next()->is(T_STRING) || $token->prev()->is(T_NEW) || $token->prev(T_ATTRIBUTE)?->prev()->is(T_NEW)) {
                        // new class {}, new class(new class {}) {}
                        $next = $token->next(['{', '(']);
                        if ($next->is('(')) {
                            $next = $next->end()->next('{');
                        }
                        $classend = max($classend ?? -1, $next->end()->index);
                    }
                    // class ClassName
                    if ($token->next()->is(T_STRING)) {
                        $result[$namespace]['alias'][$token->next()->text] = concat($namespace, '\\') . $token->next()->text;
                    }
                }
                if ($token->is(T_EXTENDS)) {
                    while (!$token->is([T_IMPLEMENTS, '{'])) {
                        $token = $token->next([T_IMPLEMENTS, '{', ',']);
                        if (!$token->prev()->is(T_NAME_FULLY_QUALIFIED)) {
                            $result[$namespace]['alias'][$token->prev()->text] ??= concat($namespace, '\\') . $token->prev()->text;
                        }
                    }
                }
                if ($token->is(T_IMPLEMENTS)) {
                    while (!$token->is(['{'])) {
                        $token = $token->next(['{', ',']);
                        if (!$token->prev()->is(T_NAME_FULLY_QUALIFIED)) {
                            $result[$namespace]['alias'][$token->prev()->text] ??= concat($namespace, '\\') . $token->prev()->text;
                        }
                    }
                }
                if ($token->is(T_CONST)) {
                    // class {**const** HOGE=1;}
                    if ($classend !== null) {
                        continue;
                    }
                    $result[$namespace]['const'][$token->next()->text] ??= concat($namespace, '\\') . $token->next()->text;
                }
                if ($token->is(T_FUNCTION)) {
                    // class {**function** hoge() {}}
                    if ($classend !== null) {
                        continue;
                    }
                    // $closure = function () {};
                    if ($token->next()->is('(')) {
                        continue;
                    }
                    $result[$namespace]['function'][$token->next()->text] ??= concat($namespace, '\\') . $token->next()->text;
                }
                if ($token->is(T_ATTRIBUTE)) {
                    $token = $token->next([T_NAME_FULLY_QUALIFIED, T_NAME_QUALIFIED, T_STRING]);
                    if (!$token->is(T_NAME_FULLY_QUALIFIED)) {
                        $result[$namespace]['alias'][$token->text] ??= concat($namespace, '\\') . $token->text;
                    }
                }
            }

            return $result;
        })();
    }
}

assert(!function_exists('ryunosuke\\NightDragon\\namespace_resolve') || (new \ReflectionFunction('ryunosuke\\NightDragon\\namespace_resolve'))->isUserDefined());
if (!function_exists('ryunosuke\\NightDragon\\namespace_resolve')) {
    /**
     * エイリアス名を完全修飾名に解決する
     *
     * 例えばあるファイルのある名前空間で `use Hoge\Fuga\Piyo;` してるときの `Piyo` を `Hoge\Fuga\Piyo` に解決する。
     *
     * Example:
     * ```php
     * // このような php ファイルがあるとして・・・
     * file_set_contents(sys_get_temp_dir() . '/symbol.php', '
     * <?php
     * namespace vendor\NS;
     *
     * use ArrayObject as AO;
     * use function strlen as SL;
     *
     * function InnerFunc(){}
     * class InnerClass{}
     * ');
     * // 下記のように解決される
     * that(namespace_resolve('AO', sys_get_temp_dir() . '/symbol.php'))->isSame('ArrayObject');
     * that(namespace_resolve('SL', sys_get_temp_dir() . '/symbol.php'))->isSame('strlen');
     * that(namespace_resolve('InnerFunc', sys_get_temp_dir() . '/symbol.php'))->isSame('vendor\\NS\\InnerFunc');
     * that(namespace_resolve('InnerClass', sys_get_temp_dir() . '/symbol.php'))->isSame('vendor\\NS\\InnerClass');
     * ```
     *
     * @package ryunosuke\Functions\Package\misc
     *
     * @param string $shortname エイリアス名
     * @param string|array $nsfiles ファイル名 or [ファイル名 => 名前空間名]
     * @param array $targets エイリアスタイプ（'const', 'function', 'alias' のいずれか）
     * @return string|null 完全修飾名。解決できなかった場合は null
     */
    function namespace_resolve(string $shortname, $nsfiles, $targets = ['const', 'function', 'alias'])
    {
        // 既に完全修飾されている場合は何もしない
        if (($shortname[0] ?? null) === '\\') {
            return $shortname;
        }

        // use Inner\Space のような名前空間の use の場合を考慮する
        $parts = explode('\\', $shortname, 2);
        $prefix = isset($parts[1]) ? array_shift($parts) : null;

        if (is_string($nsfiles)) {
            $nsfiles = [$nsfiles => []];
        }

        $targets = (array) $targets;
        foreach ($nsfiles as $filename => $namespaces) {
            $namespaces = array_flip(array_map(fn($n) => trim($n, '\\'), (array) $namespaces));
            foreach (namespace_parse($filename) as $namespace => $ns) {
                /** @noinspection PhpIllegalArrayKeyTypeInspection */
                if (!$namespaces || isset($namespaces[$namespace])) {
                    if (isset($ns['alias'][$prefix])) {
                        return $ns['alias'][$prefix] . '\\' . implode('\\', $parts);
                    }
                    foreach ($targets as $target) {
                        if (isset($ns[$target][$shortname])) {
                            return $ns[$target][$shortname];
                        }
                    }
                }
            }
        }
        return null;
    }
}

assert(!function_exists('ryunosuke\\NightDragon\\php_indent') || (new \ReflectionFunction('ryunosuke\\NightDragon\\php_indent'))->isUserDefined());
if (!function_exists('ryunosuke\\NightDragon\\php_indent')) {
    /**
     * php のコードのインデントを調整する
     *
     * baseline で基準インデント位置を指定する。
     * その基準インデントを削除した後、指定したインデントレベルでインデントするようなイメージ。
     *
     * Example:
     * ```php
     * $phpcode = '
     *     echo 123;
     *
     *     if (true) {
     *         echo 456;
     *     }
     * ';
     * // 数値指定は空白換算
     * that(php_indent($phpcode, 8))->isSame('
     *         echo 123;
     *
     *         if (true) {
     *             echo 456;
     *         }
     * ');
     * // 文字列を指定すればそれが使用される
     * that(php_indent($phpcode, "  "))->isSame('
     *   echo 123;
     *
     *   if (true) {
     *       echo 456;
     *   }
     * ');
     * // オプション指定
     * that(php_indent($phpcode, [
     *     'baseline'  => 1,    // 基準インデントの行番号（負数で下からの指定になる）
     *     'indent'    => 4,    // インデント指定（上記の数値・文字列指定はこれの糖衣構文）
     *     'trimempty' => true, // 空行を trim するか
     *     'heredoc'   => true, // Flexible Heredoc もインデントするか
     * ]))->isSame('
     *     echo 123;
     *
     *     if (true) {
     *         echo 456;
     *     }
     * ');
     * ```
     *
     * @package ryunosuke\Functions\Package\misc
     *
     * @param string $phpcode インデントする php コード
     * @param array|int|string $options オプション
     * @return string インデントされた php コード
     */
    function php_indent($phpcode, $options = [])
    {
        if (!is_array($options)) {
            $options = ['indent' => $options];
        }
        $options += [
            'baseline'  => 1,
            'indent'    => 0,
            'trimempty' => true,
            'heredoc'   => true,
        ];
        if (is_int($options['indent'])) {
            $options['indent'] = str_repeat(' ', $options['indent']);
        }

        $lines = preg_split('#\\R#u', $phpcode);
        $baseline = $options['baseline'];
        if ($baseline < 0) {
            $baseline = count($lines) + $baseline;
        }
        preg_match('@^[ \t]*@u', $lines[$baseline] ?? '', $matches);
        $indent = $matches[0] ?? '';

        $tmp = \PhpToken::tokenize("<?php $phpcode");
        array_shift($tmp);

        // トークンの正規化
        $tokens = [];
        for ($i = 0; $i < count($tmp); $i++) {
            if ($options['heredoc']) {
                // 行コメントと同じ（T_START_HEREDOC には改行が含まれている）
                if ($tmp[$i]->id === T_START_HEREDOC && preg_match('@^(<<<).*?(\\R)@um', $tmp[$i]->text, $matches)) {
                    $tmp[$i]->text = trim($tmp[$i]->text);
                    if (($tmp[$i + 1]->id ?? null) === T_ENCAPSED_AND_WHITESPACE) {
                        $tmp[$i + 1]->text = $matches[2] . $tmp[$i + 1]->text;
                    }
                    else {
                        array_splice($tmp, $i + 1, 0, [new \PhpToken(T_ENCAPSED_AND_WHITESPACE, $matches[2])]);
                    }
                }
                // php 7.3 において T_END_HEREDOC は必ず単一行になる
                if ($tmp[$i]->id === T_ENCAPSED_AND_WHITESPACE) {
                    if (($tmp[$i + 1]->id ?? null) === T_END_HEREDOC && preg_match('@^(\\s+)(.*)@um', $tmp[$i + 1]->text, $matches)) {
                        $tmp[$i]->text = $tmp[$i]->text . $matches[1];
                        $tmp[$i + 1]->text = $matches[2];
                    }
                }
            }

            $tokens[] = $tmp[$i];
        }

        // 改行を置換してインデント
        $hereing = false;
        foreach ($tokens as $i => $token) {
            if ($options['heredoc']) {
                if ($token->id === T_START_HEREDOC) {
                    $hereing = true;
                }
                if ($token->id === T_END_HEREDOC) {
                    $hereing = false;
                }
            }
            if (in_array($token->id, [T_WHITESPACE, T_COMMENT, T_DOC_COMMENT], true) || ($hereing && $token->id === T_ENCAPSED_AND_WHITESPACE)) {
                $token->text = preg_replace("@(\\R)$indent@um", '$1' . $options['indent'], $token->text);
            }
            if ($options['trimempty']) {
                if ($token->id === T_WHITESPACE) {
                    $token->text = preg_replace("@(\\R)[ \\t]+(\\R)@um", '$1$2', $token->text);
                }
            }

            $tokens[$i] = $token;
        }
        return implode('', array_column($tokens, 'text'));
    }
}

assert(!function_exists('ryunosuke\\NightDragon\\php_parse') || (new \ReflectionFunction('ryunosuke\\NightDragon\\php_parse'))->isUserDefined());
if (!function_exists('ryunosuke\\NightDragon\\php_parse')) {
    /**
     * php のコード断片をパースする
     *
     * @todo そもそも何がしたいのかよくわからない関数になってきたので動作の洗い出しが必要
     *
     * Example:
     * ```php
     * $phpcode = '<?php
     * namespace Hogera;
     * class Example
     * {
     *     // something
     * }';
     *
     * // namespace ～ ; を取得
     * $part = php_parse($phpcode, [
     *     'begin' => T_NAMESPACE,
     *     'end'   => ';',
     * ]);
     * that(implode('', array_column($part, 'text')))->isSame('namespace Hogera;');
     *
     * // class ～ { を取得
     * $part = php_parse($phpcode, [
     *     'begin' => T_CLASS,
     *     'end'   => '{',
     * ]);
     * that(implode('', array_column($part, 'text')))->isSame("class Example\n{");
     * ```
     *
     * @package ryunosuke\Functions\Package\misc
     *
     * @param string $phpcode パースする php コード
     * @param array|int $option パースオプション
     * @return \PhpToken[] トークン配列
     */
    function php_parse($phpcode, $option = [])
    {
        if (is_int($option)) {
            $option = ['flags' => $option];
        }

        $default = [
            'short_open_tag' => null, // ショートオープンタグを扱うか（null だと余計なことはせず ini に従う）
            'line'           => [],   // 行の範囲（以上以下）
            'position'       => [],   // 文字位置の範囲（以上以下）
            'begin'          => [],   // 開始トークン
            'end'            => [],   // 終了トークン
            'offset'         => 0,    // 開始トークン位置
            'flags'          => 0,    // PHPToken の $flags. TOKEN_PARSE を与えると ParseError が出ることがあるのでデフォルト 0
            'cache'          => true, // キャッシュするか否か
            'greedy'         => false,// end と nest か一致したときに処理を継続するか
            'backtick'       => true, // `` もパースするか
            'nest_token'     => [
                [')', '('],
                ['}', '{'],
                [']', '['],
                [']', '#['],
            ],
        ];
        $option += $default;

        $cachekey = var_hash($phpcode) . $option['flags'] . '-' . $option['backtick'] . '-' . var_export($option['short_open_tag'], true);
        static $cache = [];
        if (!($option['cache'] && isset($cache[$cachekey]))) {
            $position = 0;
            $backtick = '';
            $backticktoken = null;
            $backticking = false;

            $tokens = [];
            $tmp = \PhpToken::tokenize($phpcode, $option['flags']);
            for ($i = 0; $i < count($tmp); $i++) {
                $token = $tmp[$i];

                // @codeCoverageIgnoreStart
                if ($option['short_open_tag'] === true && $token->id === T_INLINE_HTML && ($p = strpos($token->text, '<?')) !== false) {
                    $newtokens = [];
                    $nlcount = 0;

                    if ($p !== 0) {
                        $html = substr($token->text, 0, $p);
                        $nlcount = preg_match_all('#\r\n|\r|\n#u', $html);
                        $newtokens[] = new \PhpToken(T_INLINE_HTML, $html, $token->line);
                    }

                    $code = substr($token->text, $p + 2);
                    $subtokens = \PhpToken::tokenize("<?php $code");
                    $subtokens[0]->text = '<?';
                    foreach ($subtokens as $subtoken) {
                        $subtoken->line += $token->line + $nlcount - 1;
                        $newtokens[] = $subtoken;
                    }

                    array_splice($tmp, $i + 1, 0, $newtokens);
                    continue;
                }
                if ($option['short_open_tag'] === false && $token->id === T_OPEN_TAG && $token->text === '<?') {
                    for ($j = $i + 1; $j < count($tmp); $j++) {
                        if ($tmp[$j]->id === T_CLOSE_TAG) {
                            break;
                        }
                    }
                    $html = implode('', array_map(fn($token) => $token->text, array_slice($tmp, $i, $j - $i + 1)));
                    array_splice($tmp, $i + 1, $j - $i, [new \PhpToken(T_INLINE_HTML, $html, $token->line)]);
                    continue;
                }
                // @codeCoverageIgnoreEnd

                if (!$option['backtick']) {
                    if ($token->text === '`') {
                        if ($backticking) {
                            $token->text = $backtick . $token->text;
                            $token->line = $backticktoken->line;
                            $token->pos = $backticktoken->pos;
                            $backtick = '';
                        }
                        else {
                            $backticktoken = $token;
                        }
                        $backticking = !$backticking;
                    }
                    if ($backticking) {
                        $backtick .= $token->text;
                        continue;
                    }
                }

                $token->pos = $position;
                $position += strlen($token->text);

                /* PhpToken になりコピーオンライトが効かなくなったので時々書き換えをチェックした方が良い
                $token = new class($token->id, $token->text, $token->line, $token->pos) extends \PhpToken {
                    private array $backup = [];
    
                    public function backup()
                    {
                        $this->backup = [
                            'id'   => $this->id,
                            'text' => $this->text,
                            'line' => $this->line,
                            'pos'  => $this->pos,
                        ];
                    }
    
                    public function __clone(): void
                    {
                        $this->backup = [];
                    }
    
                    public function __destruct()
                    {
                        foreach ($this->backup as $name => $value) {
                            assert($this->$name === $value);
                        }
                    }
                };
                $token->backup();
                 */

                $tokens[] = $token;
            }
            // @codeCoverageIgnoreStart
            if ($option['short_open_tag'] === false) {
                for ($i = 0; $i < count($tokens); $i++) {
                    if ($tokens[$i]->id === T_INLINE_HTML && isset($tokens[$i + 1]) && $tokens[$i + 1]->id === T_INLINE_HTML) {
                        $tokens[$i]->text .= $tokens[$i + 1]->text;
                        array_splice($tokens, $i + 1, 1, []);
                        $i--;
                    }
                }
            }
            // @codeCoverageIgnoreEnd
            $cache[$cachekey] = $tokens;
        }
        $tokens = $cache[$cachekey];

        $lines = $option['line'] + [-PHP_INT_MAX, PHP_INT_MAX];
        $positions = $option['position'] + [-PHP_INT_MAX, PHP_INT_MAX];
        $begin_tokens = (array) $option['begin'];
        $end_tokens = (array) $option['end'];
        // for compatible
        $nest_tokens = [];
        foreach ($option['nest_token'] as $k => $v) {
            if (is_string($k)) {
                $v = [$v, $k]; // @codeCoverageIgnore for compatible
            }
            $nest_tokens[] = $v;
        }
        $nest_start_tokens = array_column($nest_tokens, 1);
        $nest_end_tokens = array_column($nest_tokens, 0);
        $greedy = $option['greedy'];

        $result = [];
        $starting = !$begin_tokens;
        $nesting = 0;
        $offset = is_array($option['offset']) ? ($option['offset'][0] ?? 0) : $option['offset'];
        $endset = is_array($option['offset']) ? ($option['offset'][1] ?? count($tokens)) : count($tokens);

        for ($i = $offset; $i < $endset; $i++) {
            $token = $tokens[$i];

            if ($lines[0] > $token->line) {
                continue;
            }
            if ($lines[1] < $token->line) {
                continue;
            }
            if ($positions[0] > $token->pos) {
                continue;
            }
            if ($positions[1] < $token->pos) {
                continue;
            }

            foreach ($begin_tokens as $t) {
                if ($t === $token->id || $t === $token->text) {
                    $starting = true;
                    break;
                }
            }
            if (!$starting) {
                continue;
            }

            $result[$i] = $token;

            foreach ($nest_tokens as [$end_nest, $start_nest]) {
                if ($token->id === $start_nest || $token->text === $start_nest) {
                    $nesting++;
                    break;
                }
                if ($token->id === $end_nest || $token->text === $end_nest) {
                    $nesting--;
                    break;
                }
            }

            foreach ($end_tokens as $t) {
                if ($t === $token->id || $t === $token->text) {
                    if ($nesting <= 0 || ($nesting === 1 && in_array($t, $nest_start_tokens, true))) {
                        if ($nesting === 0 && $greedy && in_array($t, $nest_end_tokens, true)) {
                            break;
                        }
                        break 2;
                    }
                    break;
                }
            }
        }
        return $result;
    }
}

assert(!function_exists('ryunosuke\\NightDragon\\php_strip') || (new \ReflectionFunction('ryunosuke\\NightDragon\\php_strip'))->isUserDefined());
if (!function_exists('ryunosuke\\NightDragon\\php_strip')) {
    /**
     * 文字列から php コードを取り除く
     *
     * 正確にはオプションの replacer で指定したものに置換される（デフォルト空文字なので削除になる）。
     * replacer にクロージャを渡すと(phpコード, 出現番号) が渡ってくるので、それに応じて値を返せばそれに置換される。
     * 文字列を指定すると自動で出現番号が付与される。
     *
     * $mapping 配列には「どれをどのように」と言った変換表が格納される。
     * 典型的には strtr に渡して php コードを復元させるのに使用する。
     *
     * Example:
     * ```php
     * $phtml = 'begin php code <?php echo 123 ?> end';
     * // php コードが消えている
     * that(php_strip($phtml))->is('begin php code  end');
     * // $mapping を使用すると元の文字列に復元できる
     * $html = php_strip($phtml, [], $mapping);
     * that(strtr($html, $mapping))->is($phtml);
     * ```
     *
     * @package ryunosuke\Functions\Package\misc
     *
     * @param string $phtml php コードを含む文字列
     * @param array $option オプション配列
     * @param array $mapping 変換表が格納される参照変数
     * @return string php コードが除かれた文字列
     */
    function php_strip($phtml, $option = [], &$mapping = [])
    {
        $option = array_replace([
            'short_open_tag' => true,
            'trailing_break' => true,
            'replacer'       => func_num_args() === 3 ? null : '',
        ], $option);

        $replacer = $option['replacer'];
        if ($replacer === '') {
            $replacer = fn($phptag, $n) => '';
        }
        if ($replacer === null) {
            $replacer = unique_string($phtml, 64);
        }

        $tmp = php_parse($phtml, $option);

        if ($option['trailing_break']) {
            $tokens = $tmp;
        }
        else {
            $tokens = [];
            $echoopen = false;
            $taglength = strlen('?>');
            foreach ($tmp as $token) {
                if ($token->id === T_OPEN_TAG_WITH_ECHO) {
                    $echoopen = true;
                }
                if ($echoopen && $token->id === T_CLOSE_TAG && isset($token->text[$taglength])) {
                    $echoopen = false;

                    $tokens[] = new \PhpToken(
                        $token->id,
                        rtrim($token->text),
                        $token->line,
                        $token->pos,
                    );
                    $tokens[] = new \PhpToken(
                        T_INLINE_HTML,
                        substr($token->text, $taglength),
                        $token->line,
                        $token->pos + $taglength,
                    );
                }
                else {
                    $tokens[] = $token;
                }
            }
        }

        $offsets = [];
        foreach ($tokens as $token) {
            if ($token->id === T_OPEN_TAG || $token->id === T_OPEN_TAG_WITH_ECHO) {
                $offsets[] = [$token->pos, null];
            }
            elseif ($token->id === T_CLOSE_TAG) {
                $lastkey = count($offsets) - 1;
                $offsets[$lastkey][1] = $token->pos + strlen($token->text) - $offsets[$lastkey][0];
            }
        }
        if ($offsets) {
            $lastkey = count($offsets) - 1;
            $offsets[$lastkey][1] = $offsets[$lastkey][1] ?? strlen($phtml) - $offsets[$lastkey][0];
        }

        $mapping = [];
        foreach (array_reverse($offsets) as $n => [$offset, $length]) {
            if ($replacer instanceof \Closure) {
                $mapping[$n] = substr($phtml, $offset, $length);
                $phtml = substr_replace($phtml, $replacer($mapping[$n], $n), $offset, $length);
            }
            else {
                $tag = $replacer . $n;
                $mapping[$tag] = substr($phtml, $offset, $length);
                $phtml = substr_replace($phtml, $tag, $offset, $length);
            }
        }

        return $phtml;
    }
}

assert(!function_exists('ryunosuke\\NightDragon\\php_tokens') || (new \ReflectionFunction('ryunosuke\\NightDragon\\php_tokens'))->isUserDefined());
if (!function_exists('ryunosuke\\NightDragon\\php_tokens')) {
    /**
     * PhpToken に便利メソッドを生やした配列を返す
     *
     * php_parse とは似て非なる（あっちは何がしたいのかよく分からなくなっている）。
     * この関数はシンプルに PhpToken の拡張版として動作する。
     *
     * 生えているメソッドは下記。
     * - __debugInfo: デバッグしやすい情報で吐き出す
     * - clone: 新プロパティを指定して clone する
     * - name: getTokenName のエイリアス
     * - prev: 条件一致した直前のトークンを返す
     *   - 引数未指定時は isIgnorable でないもの
     * - next: 条件一致した直後のトークンを返す
     *   - 引数未指定時は isIgnorable でないもの
     * - find: ブロック内部を読み飛ばしつつ指定トークンを探す
     * - end: 自身の対応するペアトークンまで飛ばして返す
     *   - 要するに { や (, " などの中途半端ではない終わりのトークンを返す
     * - contents: 自身と end 間のトークンを文字列化する
     * - resolve: text が名前空間を解決して完全修飾になったトークンを返す
     *
     * Example:
     * ```php
     * $phpcode = '<?php
     * // dummy
     * namespace Hogera;
     * class Example
     * {
     *     // something
     * }';
     *
     * $tokens = php_tokens($phpcode);
     * // name でトークン名が得られる
     * that($tokens[0])->name()->is('T_OPEN_TAG');
     * // ↑の次はコメントだが next で namespace が得られる
     * that($tokens[0])->next()->text->is('namespace');
     * // 同じく↑の次はホワイトスペースだが next で Hogera が得られる
     * that($tokens[0])->next()->next()->text->is('Hogera');
     * ```
     *
     * @package ryunosuke\Functions\Package\misc
     *
     * @noinspection PhpPossiblePolymorphicInvocationInspection
     *
     * @param string $phpcode パースする php コード
     * @param int $flags パースオプション
     * @return \PhpTokens[] トークン配列
     */
    function php_tokens(string $code, int $flags = 0)
    {
        $PhpToken = null;
        $PhpToken ??= new #[\AllowDynamicProperties] class (0, "") extends \PhpToken {
            public array $tokens;
            public int   $index;

            public function __debugInfo(): array
            {
                $result = get_object_vars($this);

                unset($result['tokens'], $result['cache']);

                $result['name'] = $this->name();
                $result['prev'] = $this->prev()?->getTokenName();
                $result['next'] = $this->next()?->getTokenName();

                return $result;
            }

            public function clone(...$newparams): self
            {
                $that = clone $this;
                foreach ($newparams as $param => $value) {
                    $that->{$param} = $value;
                }
                return $that;
            }

            public function name(): string
            {
                return $this->getTokenName();
            }

            public function prev($condition = null): ?self
            {
                $condition ??= fn($token) => !$token->isIgnorable();
                return $this->sibling(-1, $condition);
            }

            public function next($condition = null): ?self
            {
                $condition ??= fn($token) => !$token->isIgnorable();
                return $this->sibling(+1, $condition);
            }

            public function find($condition): ?self
            {
                $condition = (array) $condition;
                $token = $this;
                while (true) {
                    $token = $token->sibling(+1, array_merge($condition, ['{', '${', '"', T_START_HEREDOC, '#[', '[', '(']));
                    if ($token === null) {
                        return null;
                    }
                    if ($token->is($condition)) {
                        return $token;
                    }
                    $token = $token->end();
                }
            }

            public function end(): self
            {
                $skip = function ($starts, $ends) {
                    $token = $this;
                    while (true) {
                        $token = $token->sibling(+1, array_merge($starts, $ends)) ?? throw new \DomainException(sprintf("token mismatch(line:%d, pos:%d, '%s')", $token->line, $token->pos, $token->text));
                        if ($token->is($starts)) {
                            $token = $token->end();
                        }
                        elseif ($token->is($ends)) {
                            return $token;
                        }
                    }
                };

                if ($this->is('"')) {
                    return $skip(['{', '${'], ['"']);
                }
                if ($this->is('`')) {
                    return $skip(['{', '${'], ['`']);
                }
                if ($this->is(T_START_HEREDOC)) {
                    return $skip(['{', '${'], [T_END_HEREDOC]);
                }
                if ($this->is('#[')) {
                    return $skip(['#[', '['], [']']);
                }
                if ($this->is('[')) {
                    return $skip(['#[', '['], [']']);
                }
                if ($this->is('${')) {
                    return $skip(['${'], ['}']); // @codeCoverageIgnore deprecated php8.2
                }
                if ($this->is('{')) {
                    return $skip(['{', '"'], ['}']);
                }
                if ($this->is('(')) {
                    return $skip(['('], [')']);
                }

                throw new \DomainException(sprintf("token is not pairable(line:%d, pos:%d, '%s')", $this->line, $this->pos, $this->text));
            }

            public function contents(?int $end = null): string
            {
                $end ??= $this->end()->index;
                return implode('', array_column(array_slice($this->tokens, $this->index, $end - $this->index + 1), 'text'));
            }

            public function resolve($ref): string
            {
                $var_export = fn($v) => var_export($v, true);
                $prev = $this->prev();
                $next = $this->next();

                $text = $this->text;
                if ($this->id === T_STRING) {
                    $namespaces = [$ref->getNamespaceName()];
                    if ($ref instanceof \ReflectionFunctionAbstract) {
                        $namespaces[] = $ref->getClosureScopeClass()?->getNamespaceName();
                    }
                    if ($prev->id === T_NEW || $prev->id === T_ATTRIBUTE || $next->id === T_DOUBLE_COLON || $next->id === T_VARIABLE || $next->text === '{') {
                        $text = namespace_resolve($text, $ref->getFileName(), 'alias') ?? $text;
                    }
                    elseif ($next->text === '(') {
                        $text = namespace_resolve($text, $ref->getFileName(), 'function') ?? $text;
                        // 関数・定数は use しなくてもグローバルにフォールバックされる（=グローバルと名前空間の区別がつかない）
                        foreach ($namespaces as $namespace) {
                            if (!function_exists($text) && function_exists($nstext = "\\$namespace\\$text")) {
                                $text = $nstext;
                                break;
                            }
                        }
                    }
                    else {
                        $text = namespace_resolve($text, $ref->getFileName(), 'const') ?? $text;
                        // 関数・定数は use しなくてもグローバルにフォールバックされる（=グローバルと名前空間の区別がつかない）
                        foreach ($namespaces as $namespace) {
                            if (!const_exists($text) && const_exists($nstext = "\\$namespace\\$text")) {
                                $text = $nstext;
                                break;
                            }
                        }
                    }
                }

                // マジック定数の解決
                if ($this->id === T_DIR) {
                    $text = $var_export(dirname($ref->getFileName()));
                }
                if ($this->id === T_FILE) {
                    $text = $var_export($ref->getFileName());
                }
                if ($this->id === T_NS_C) {
                    $text = $var_export($ref->getNamespaceName());
                }
                return $text;
            }

            private function sibling(int $step, $condition)
            {
                if (is_array($condition) || !is_callback($condition)) {
                    $condition = fn($token) => $token->is($condition);
                }
                for ($i = $this->index + $step; isset($this->tokens[$i]); $i += $step) {
                    if ($condition($this->tokens[$i])) {
                        return $this->tokens[$i];
                    }
                }
                return null;
            }
        };

        $tokens = $PhpToken::tokenize($code, $flags);
        foreach ($tokens as $i => $token) {
            $token->tokens = $tokens;
            $token->index = $i;
        }
        return $tokens;
    }
}

assert(!function_exists('ryunosuke\\NightDragon\\unique_string') || (new \ReflectionFunction('ryunosuke\\NightDragon\\unique_string'))->isUserDefined());
if (!function_exists('ryunosuke\\NightDragon\\unique_string')) {
    /**
     * 文字列に含まれない文字列を生成する
     *
     * 例えば http のマルチパートバウンダリのような、「競合しない文字列」を生成する。
     * 実装は愚直に文字列を調べて存在しなければそれを返すようになっている。
     * 一応初期値や文字セットは指定可能。
     *
     * $initial に int を与えると初期値としてその文字数分 $charlist から確保する。
     * 例えば生成後の変更が前提で、ある程度の長さを担保したいときに指定すれば最低でもその長さ以上は保証される。
     * $initial に string を与えるとそれがそのまま初期値として使用される。
     * 例えば「ほぼ存在しない文字列」が予測できるのであればそれを指定すれば無駄な処理が省ける。
     *
     * Example:
     * ```php
     * // 単純に呼ぶと生成1,2文字程度の文字列になる
     * that(unique_string('hello, world'))->stringLengthEqualsAny([1, 2]);
     * // 数値を含んでいないので候補文字に数値のみを指定すれば1文字で「存在しない文字列」となる
     * that(unique_string('hello, world', null, range(0, 9)))->stringLengthEquals(1);
     * // int を渡すと最低でもそれ以上は保証される
     * that(unique_string('hello, world', 5))->stringLengthEqualsAny([5, 6]);
     * // string を渡すとそれが初期値となる
     * that(unique_string('hello, world', 'prefix-'))->stringStartsWith('prefix');
     * ```
     *
     * @package ryunosuke\Functions\Package\random
     *
     * @param string $source 元文字列
     * @param string|int $initial 初期文字列あるいは文字数
     * @param string|array $charlist 使用する文字セット
     * @return string 一意な文字列
     */
    function unique_string($source, $initial = null, $charlist = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ')
    {
        assert(is_stringable($initial) || is_int($initial) || is_null($initial));

        if (is_stringable($charlist)) {
            $charlist = preg_split('//', $charlist, -1, PREG_SPLIT_NO_EMPTY);
        }

        $charlength = count($charlist);
        if ($charlength === 0) {
            throw new \InvalidArgumentException('charlist is empty.');
        }

        $result = '';
        if (is_int($initial)) {
            shuffle($charlist);
            $result = implode('', array_slice($charlist, 0, $initial));
        }
        elseif (is_null($initial)) {
            $result .= $charlist[mt_rand(0, $charlength - 1)];
        }
        else {
            $result = $initial;
        }

        while ((($p = strpos($source, $result, $p ?? 0)) !== false)) {
            $result .= $charlist[mt_rand(0, $charlength - 1)];
        }

        return $result;
    }
}

assert(!function_exists('ryunosuke\\NightDragon\\callable_code') || (new \ReflectionFunction('ryunosuke\\NightDragon\\callable_code'))->isUserDefined());
if (!function_exists('ryunosuke\\NightDragon\\callable_code')) {
    /**
     * callable のコードブロックを返す
     *
     * 返り値は2値の配列。0番目の要素が定義部、1番目の要素が処理部を表す。
     *
     * Example:
     * ```php
     * list($meta, $body) = callable_code(function (...$args) {return true;});
     * that($meta)->isSame('function (...$args)');
     * that($body)->isSame('{return true;}');
     *
     * // ReflectionFunctionAbstract を渡しても動作する
     * list($meta, $body) = callable_code(new \ReflectionFunction(function (...$args) {return true;}));
     * that($meta)->isSame('function (...$args)');
     * that($body)->isSame('{return true;}');
     * ```
     *
     * @package ryunosuke\Functions\Package\reflection
     *
     * @param callable|\ReflectionFunctionAbstract $callable コードを取得する callable
     * @param bool $return_token true にすると生のトークン配列で返す
     * @return array ['定義部分', '{処理コード}']
     */
    function callable_code($callable, bool $return_token = false)
    {
        $ref = $callable instanceof \ReflectionFunctionAbstract ? $callable : reflect_callable($callable);
        $contents = file($ref->getFileName());
        $start = $ref->getStartLine();
        $end = $ref->getEndLine();
        $codeblock = implode('', array_slice($contents, $start - 1, $end - $start + 1));

        $tokens = php_tokens("<?php $codeblock");

        $begin = $tokens[0]->next([T_FUNCTION, T_FN]);
        $close = $begin->next(['{', T_DOUBLE_ARROW]);

        if ($begin->is(T_FN)) {
            $meta = array_slice($tokens, $begin->index, $close->prev()->index - $begin->index + 1);
            $temp = $close->find([';', ',', T_CLOSE_TAG]);
            // アロー関数は終了トークンが明確ではない
            // - $x = fn() => 123;         // セミコロン
            // - $x = fn() => [123];       // セミコロンであって ] ではない
            // - $x = [fn() => 123, null]; // こうだとカンマになるし
            // - $x = [fn() => 123];       // こうだと ] になる
            // しっかり実装できなくもないが、（多分）戻り読みが必要なのでここでは構文チェックをパスするまでループする実装とした
            while ($temp) {
                $test = array_slice($tokens, $close->next()->index, $temp->index - $close->next()->index);
                $text = implode('', array_column($test, 'text'));
                try {
                    /** @noinspection PhpExpressionResultUnusedInspection */
                    token_get_all("<?php $text;", TOKEN_PARSE);
                    break;
                }
                catch (\Throwable) {
                    $temp = $temp->prev();
                }
            }
            $body = array_slice($tokens, $close->next()->index, $temp ? $temp->index - $close->next()->index : null);
        }
        else {
            $meta = array_slice($tokens, $begin->index, $close->index - $begin->index);
            $body = $close->end();
            $body = array_slice($tokens, $close->index, $body->index - $close->index + 1);
        }

        if ($return_token) {
            return [$meta, $body];
        }

        return [trim(implode('', array_column($meta, 'text'))), trim(implode('', array_column($body, 'text')))];
    }
}

assert(!function_exists('ryunosuke\\NightDragon\\parameter_length') || (new \ReflectionFunction('ryunosuke\\NightDragon\\parameter_length'))->isUserDefined());
if (!function_exists('ryunosuke\\NightDragon\\parameter_length')) {
    /**
     * callable の引数の数を返す
     *
     * Example:
     * ```php
     * // trim の引数は2つ
     * that(parameter_length('trim'))->isSame(2);
     * // trim の必須引数は1つ
     * that(parameter_length('trim', true))->isSame(1);
     * ```
     *
     * @package ryunosuke\Functions\Package\reflection
     *
     * @param callable $callable 対象 callable
     * @param bool $require_only true を渡すと必須パラメータの数を返す
     * @param bool $thought_variadic 可変引数を考慮するか。 true を渡すと可変引数の場合に無限長を返す
     * @return int 引数の数
     */
    function parameter_length($callable, $require_only = false, $thought_variadic = false)
    {
        /** @var \ReflectionFunctionAbstract $ref */
        $ref = reflect_callable($callable);
        if ($thought_variadic && $ref->isVariadic()) {
            return INF;
        }
        elseif ($require_only) {
            return $ref->getNumberOfRequiredParameters();
        }
        else {
            return $ref->getNumberOfParameters();
        }
    }
}

assert(!function_exists('ryunosuke\\NightDragon\\reflect_callable') || (new \ReflectionFunction('ryunosuke\\NightDragon\\reflect_callable'))->isUserDefined());
if (!function_exists('ryunosuke\\NightDragon\\reflect_callable')) {
    /**
     * callable から ReflectionFunctionAbstract を生成する
     *
     * 実際には ReflectionFunctionAbstract を下記の独自拡張した Reflection クラスを返す（メソッドのオーバーライド等はしていないので完全互換）。
     * - __invoke: 元となったオブジェクトを $this として invoke する（関数・クロージャは invoke と同義）
     * - call: 実行 $this を指定して invoke する（クロージャ・メソッドのみ）
     *   - 上記二つは __call/__callStatic のメソッドも呼び出せる
     * - getDeclaration: 宣言部のコードを返す
     * - getCode: 定義部のコードを返す
     * - isAnonymous: 無名関数なら true を返す（8.2 の isAnonymous 互換）
     * - isArrow: アロー演算子で定義されたかを返す（クロージャのみ）
     * - isStatic: $this バインド可能かを返す（クロージャのみ）
     * - getUsedVariables: use している変数配列を返す（クロージャのみ）
     * - getClosure: 元となったオブジェクトを $object としたクロージャを返す（メソッドのみ）
     *   - 上記二つは __call/__callStatic のメソッドも呼び出せる
     * - getTraitMethod: トレイト側のリフレクションを返す（メソッドのみ）
     *
     * Example:
     * ```php
     * that(reflect_callable('sprintf'))->isInstanceOf(\ReflectionFunction::class);
     * that(reflect_callable('\Closure::bind'))->isInstanceOf(\ReflectionMethod::class);
     *
     * $x = 1;
     * $closure = function ($a, $b) use (&$x) { return $a + $b; };
     * $reflection = reflect_callable($closure);
     * // 単純実行
     * that($reflection(1, 2))->is(3);
     * // 無名クラスを $this として実行
     * that($reflection->call(new class(){}, 1, 2))->is(3);
     * // 宣言部を返す
     * that($reflection->getDeclaration())->is('function ($a, $b) use (&$x)');
     * // 定義部を返す
     * that($reflection->getCode())->is('{ return $a + $b; }');
     * // static か返す
     * that($reflection->isStatic())->is(false);
     * // use 変数を返す
     * that($reflection->getUsedVariables())->is(['x' => 1]);
     * ```
     *
     * @package ryunosuke\Functions\Package\reflection
     *
     * @param callable $callable 対象 callable
     * @return \ReflectCallable|\ReflectionFunction|\ReflectionMethod リフレクションインスタンス
     */
    function reflect_callable($callable)
    {
        // callable チェック兼 $call_name 取得
        if (!is_callable($callable, true, $call_name)) {
            throw new \InvalidArgumentException("'$call_name' is not callable");
        }

        if (is_string($call_name) && strpos($call_name, '::') === false) {
            return new class($callable) extends \ReflectionFunction {
                private $definition;

                public function __invoke(...$args): mixed
                {
                    return $this->invoke(...$args);
                }

                public function getDeclaration(): string
                {
                    return ($this->definition ??= callable_code($this))[0];
                }

                public function getCode(): string
                {
                    return ($this->definition ??= callable_code($this))[1];
                }

                public function isAnonymous(): bool
                {
                    return false;
                }
            };
        }
        elseif ($callable instanceof \Closure) {
            return new class($callable) extends \ReflectionFunction {
                private $callable;
                private $definition;

                public function __construct($function)
                {
                    parent::__construct($function);

                    $this->callable = $function;
                }

                public function __invoke(...$args): mixed
                {
                    return $this->invoke(...$args);
                }

                public function call($newThis = null, ...$args): mixed
                {
                    return ($this->callable)->call($newThis ?? $this->getClosureThis(), ...$args);
                }

                public function getDeclaration(): string
                {
                    return ($this->definition ??= callable_code($this))[0];
                }

                public function getCode(): string
                {
                    return ($this->definition ??= callable_code($this))[1];
                }

                public function isAnonymous(): bool
                {
                    if (method_exists(\ReflectionFunction::class, 'isAnonymous')) {
                        return parent::isAnonymous(); // @codeCoverageIgnore
                    }

                    return strpos($this->name, '{closure}') !== false;
                }

                public function isArrow(): bool
                {
                    // しっかりやるなら PHPToken を使った方がいいけど今の php 構文ならこれで大丈夫のはず
                    return str_starts_with($this->getDeclaration(), 'fn') !== false;
                }

                public function isStatic(): bool
                {
                    return !is_bindable_closure($this->callable);
                }

                public function getUsedVariables(): array
                {
                    if (method_exists(\ReflectionFunction::class, 'getClosureUsedVariables')) {
                        return parent::getClosureUsedVariables(); // @codeCoverageIgnore
                    }

                    $uses = object_properties($this->callable);
                    unset($uses['this']);
                    return $uses;
                }
            };
        }
        else {
            [$class, $method] = explode('::', $call_name, 2);
            // for タイプ 5: 相対指定による静的クラスメソッドのコール (PHP 5.3.0 以降)
            if (strpos($method, 'parent::') === 0) {
                [, $method] = explode('::', $method);
                $class = get_parent_class($class);
            }

            $called_name = '';
            if (!method_exists(is_array($callable) && is_object($callable[0]) ? $callable[0] : $class, $method)) {
                $called_name = $method;
                $method = is_array($callable) && is_object($callable[0]) ? '__call' : '__callStatic';
            }

            return new class($class, $method, $callable, $called_name) extends \ReflectionMethod {
                private $callable;
                private $call_name;
                private $definition;

                public function __construct($class, $method, $callable, $call_name)
                {
                    parent::__construct($class, $method);

                    $this->setAccessible(true); // 8.1 はデフォルトで true になるので模倣する
                    $this->callable = $callable;
                    $this->call_name = $call_name;
                }

                public function __invoke(...$args): mixed
                {
                    if ($this->call_name) {
                        $args = [$this->call_name, $args];
                    }
                    return $this->invoke($this->isStatic() ? null : $this->callable[0], ...$args);
                }

                public function call($newThis = null, ...$args): mixed
                {
                    if ($this->call_name) {
                        $args = [$this->call_name, $args];
                    }
                    return $this->getClosure($newThis ?? ($this->isStatic() ? null : $this->callable[0]))(...$args);
                }

                public function getDeclaration(): string
                {
                    return ($this->definition ??= callable_code($this))[0];
                }

                public function getCode(): string
                {
                    return ($this->definition ??= callable_code($this))[1];
                }

                public function isAnonymous(): bool
                {
                    return false;
                }

                public function getClosure(?object $object = null): \Closure
                {
                    $name = strtolower($this->name);

                    if ($this->isStatic()) {
                        if ($name === '__callstatic') {
                            return \Closure::fromCallable([$this->class, $this->call_name]);
                        }
                        return parent::getClosure();
                    }

                    $object ??= $this->callable[0];
                    if ($name === '__call') {
                        return \Closure::fromCallable([$object, $this->call_name]);
                    }
                    return parent::getClosure($object);
                }

                public function getTraitMethod(): ?\ReflectionMethod
                {
                    $name = strtolower($this->name);
                    $class = $this->getDeclaringClass();
                    $aliases = array_change_key_case($class->getTraitAliases(), CASE_LOWER);

                    if (!isset($aliases[$name])) {
                        if ($this->getFileName() === $class->getFileName()) {
                            return null;
                        }
                        else {
                            return $this;
                        }
                    }

                    [$tname, $mname] = explode('::', $aliases[$name]);
                    $result = new self($tname, $mname, $this->callable, $this->call_name);

                    // alias を張ったとしても自身で再宣言はエラーなく可能で、その場合自身が採用されるようだ
                    if (false
                        || $this->getFileName() !== $result->getFileName()
                        || $this->getStartLine() !== $result->getStartLine()
                        || $this->getEndLine() !== $result->getEndLine()
                    ) {
                        return null;
                    }

                    return $result;
                }
            };
        }
    }
}

assert(!function_exists('ryunosuke\\NightDragon\\reflect_type_resolve') || (new \ReflectionFunction('ryunosuke\\NightDragon\\reflect_type_resolve'))->isUserDefined());
if (!function_exists('ryunosuke\\NightDragon\\reflect_type_resolve')) {
    /**
     * ReflectionType の型に \\ を付与する
     *
     * php8.0 で ReflectionType の __toString が解放されたけど、それをそのまま埋め込んだりすると \\ がないのでエラーになったりする。
     * この関数を通してから埋め込めば \\ が付くので回避できる、という非常にニッチな関数。
     *
     * 型 exists で判定するため、付与するクラスは存在している必要がある（オプション引数で対応するかもしれない）。
     *
     * Example:
     * ```php
     * // このような DNF 型も形式を保ったまま \\ を付与できる
     * that(reflect_type_resolve('(Countable&Traversable)|object'))->is('(\\Countable&\\Traversable)|object');
     * ```
     *
     * @package ryunosuke\Functions\Package\reflection
     *
     * @param ?string $type string だが実用上は getType 等で得られるインスタンスでよい
     * @return ?string 解決された文字列
     */
    function reflect_type_resolve(?string $type): ?string
    {
        if ($type === null) {
            return null;
        }

        // 拡張関数が string|null ではなく ?string で返すことがあるので ? を含める
        // 8.1以上では交差型もあり得るので (&) も含める
        // そして PREG_SPLIT_DELIM_CAPTURE で分割して再結合すれば元の形式のまま得られる
        $types = preg_split('#([?()|&])#', $type, -1, PREG_SPLIT_DELIM_CAPTURE);
        $types = array_map(fn($v) => type_exists($v) ? "\\" . ltrim($v, '\\') : $v, $types);
        return implode('', $types);
    }
}

assert(!function_exists('ryunosuke\\NightDragon\\reflect_types') || (new \ReflectionFunction('ryunosuke\\NightDragon\\reflect_types'))->isUserDefined());
if (!function_exists('ryunosuke\\NightDragon\\reflect_types')) {
    /**
     * ReflectionType の型配列を返す
     *
     * ReflectionType のインターフェース・仕様がコロコロ変わってついていけないので関数化した。
     *
     * ReflectionType に準ずるインスタンスを渡すと取り得る候補を配列ライクなオブジェクトで返す。
     * 引数は配列で複数与えても良い。よしなに扱って複数型として返す。
     * また「Type が一意に導出できる Reflection」を渡しても良い（ReflectionProperty など）。
     * null を与えた場合はエラーにはならず、スルーされる（getType は null を返し得るので利便性のため）。
     *
     * 単純に ReflectionType の配列ライクなオブジェクトを返すが、そのオブジェクトは `__toString` が実装されており、文字列化するとパイプ区切りの型文字列を返す。
     * これは 8.0 における ReflectionUnionType の `__toString` を模倣したものである。
     * 互換性のある型があった場合、上位の型に内包されて型文字列としては出現しない。
     *
     * Countable も実装されているが、その結果は「内部 Type の数」ではなく、論理的に「取り得る型の数」を返す。
     * 例えば `?int` は型としては1つだが、実際は int, null の2つを取り得るため、 count は 2 を返す。
     * 端的に言えば「`__toString` のパイプ区切りの型の数」を返す。
     *
     * あとは便利メソッドとして下記が生えている。
     *
     * - jsonSerialize: JsonSerializable 実装
     * - getTypes: 取り得る型をすべて返す（ReflectionUnionType 互換）
     * - getName: ReflectionUnionType 非互換 toString な型宣言文字列を返す
     * - allows: その値を取りうるか判定して返す
     *
     * ReflectionUnionType とは完全互換ではないので、php8.0が完全に使える環境であれば素直に ReflectionUnionType を使ったほうが良い。
     * （「常に（型分岐せずに）複数形で扱える」程度のメリットしかない。allows は惜しいが）。
     *
     * ちなみに型の変遷は下記の通り。
     *
     * - php7.1: ReflectionType::__toString が非推奨になった
     * - php7.1: ReflectionNamedType が追加され、各種 getType でそれを返すようになった
     * - php8.0: ReflectionType::__toString が非推奨ではなくなった
     * - php8.0: ReflectionUnionType が追加され、複合の場合は getType でそれを返すようになった
     *
     * Example:
     * ```php
     * $object = new class {
     *     function method(object $o):?string {}
     * };
     * $method = new \ReflectionMethod($object, 'method');
     * $types = reflect_types($method->getParameters()[0]->getType());
     * // 文字列化すると型宣言文字列を返すし、配列アクセスや count, iterable でそれぞれの型が得られる
     * that((string) $types)->is('object');
     * that($types[0])->isInstanceOf(\ReflectionType::class);
     * that(iterator_to_array($types))->eachIsInstanceOf(\ReflectionType::class);
     * that(count($types))->is(1);
     * // 返り値でも同じ（null 許容なので null が付くし count も 2 になる）
     * $types = reflect_types($method->getReturnType());
     * that((string) $types)->is('string|null');
     * that(count($types))->is(2);
     * ```
     *
     * @package ryunosuke\Functions\Package\reflection
     *
     * @param \ReflectionFunctionAbstract|\ReflectionType|\ReflectionType[]|null $reflection_type getType 等で得られるインスタンス
     * @return \ReflectTypes|object
     */
    function reflect_types($reflection_type = null)
    {
        if (!is_array($reflection_type)) {
            $reflection_type = [$reflection_type];
        }

        foreach ($reflection_type as $n => $rtype) {
            if ($rtype instanceof \ReflectionProperty) {
                $reflection_type[$n] = $rtype->getType();
            }
            if ($rtype instanceof \ReflectionFunctionAbstract) {
                $reflection_type[$n] = $rtype->getReturnType();
            }
            if ($rtype instanceof \ReflectionParameter) {
                $reflection_type[$n] = $rtype->getType();
            }
        }

        /**
         * @mixin \ReflectionType
         * @mixin \ReflectionNamedType
         * @mixin \ReflectionUnionType
         * @mixin \ReflectionIntersectionType
         */
        return new class(...$reflection_type)
            extends \stdClass
            implements \IteratorAggregate, \ArrayAccess, \Countable, \JsonSerializable {

            private const PSEUDO = [
                'mixed'    => [],
                'static'   => ['object', 'mixed'],
                'self'     => ['static', 'object', 'mixed'],
                'parent'   => ['static', 'object', 'mixed'],
                'callable' => ['mixed'],
                'iterable' => ['mixed'],
                'object'   => ['mixed'],
                'array'    => ['iterable', 'mixed'],
                'string'   => ['mixed'],
                'int'      => ['mixed'],
                'float'    => ['mixed'],
                'bool'     => ['mixed'],
                'false'    => ['bool', 'mixed'],
                'null'     => ['mixed'],
                'void'     => [],
            ];

            public function __construct(?\ReflectionType ...$reflection_types)
            {
                $types = [];
                foreach ($reflection_types as $type) {
                    if ($type === null) {
                        continue;
                    }

                    $types = array_merge($types, $type instanceof \ReflectionUnionType ? $type->getTypes() : [$type]);
                }

                // 配列キャストで配列を得たいので下手にフィールドを宣言せず直に生やす
                foreach ($types as $n => $type) {
                    $this->$n = $type;
                }
            }

            public function __toString(): string
            {
                return implode('|', $this->toStrings(true, true));
            }

            public function getIterator(): \Traversable
            {
                // yield from $this->getTypes();
                return new \ArrayIterator($this->getTypes());
            }

            public function offsetExists($offset): bool
            {
                return isset($this->$offset);
            }

            public function offsetGet($offset): mixed
            {
                return $this->$offset;
            }

            public function offsetSet($offset, $value): void
            {
                // for debug
                if (is_string($value)) {
                    $value = new class ($value, self::PSEUDO) extends \ReflectionNamedType {
                        private $typename;
                        private $nullable;
                        private $builtins;

                        public function __construct($typename, $builtins)
                        {
                            $this->typename = ltrim($typename, '?');
                            $this->nullable = $typename[0] === '?';
                            $this->builtins = $builtins;
                        }

                        public function getName(): string { return $this->typename; }

                        public function allowsNull(): bool { return $this->nullable; }

                        public function isBuiltin(): bool { return isset($this->builtins[$this->typename]); }

                        public function __toString(): string { return $this->getName(); }
                    };
                }

                assert($value instanceof \ReflectionType);
                if ($offset === null) {
                    $offset = max(array_keys($this->getTypes()) ?: [-1]) + 1;
                }
                $this->$offset = $value;
            }

            public function offsetUnset($offset): void
            {
                unset($this->$offset);
            }

            public function count(): int
            {
                return count($this->toStrings(true, false));
            }

            public function jsonSerialize(): array
            {
                return $this->toStrings(true, true);
            }

            public function getName(): string
            {
                $types = array_flip($this->toStrings(true, true));
                $nullable = false;
                if (isset($types['null']) && count($types) === 2) {
                    unset($types['null']);
                    $nullable = true;
                }

                $result = [];
                foreach ($types as $type => $dummy) {
                    $result[] = (isset(self::PSEUDO[$type]) ? '' : '\\') . $type;
                }
                return ($nullable ? '?' : '') . implode('|', $result);
            }

            public function getTypes(): array
            {
                return (array) $this;
            }

            public function allows($type, $strict = false): bool
            {
                $types = array_flip($this->toStrings(false, false));

                if (isset($types['mixed'])) {
                    return true;
                }

                foreach ($types as $allow => $dummy) {
                    if (function_exists($f = "is_$allow") && $f($type)) {
                        return true;
                    }
                    if (is_a($type, $allow, true)) {
                        return true;
                    }
                }

                if (!$strict) {
                    if (is_int($type) || is_float($type) || is_bool($type)) {
                        if (isset($types['int']) || isset($types['float']) || isset($types['bool']) || isset($types['string'])) {
                            return true;
                        }
                    }
                    if (is_string($type) || (is_object($type) && method_exists($type, '__toString'))) {
                        if (isset($types['string'])) {
                            return true;
                        }
                        if ((isset($types['int']) || isset($types['float'])) && is_numeric("$type")) {
                            return true;
                        }
                    }
                }
                return false;
            }

            private function toStrings($ignore_compatible = true, $sort = true): array
            {
                $types = [];
                foreach ($this->getTypes() as $type) {
                    // ドキュメント上は「ReflectionNamedType を返す可能性があります」とのことなので getName 前提はダメ
                    // かといって文字列化前提だと 7.1 以降で deprecated が出てしまう
                    // つまり愚直に分岐するか @ で抑制するくらいしか多バージョン対応する術がない（7.1 の deprecated を解除して欲しい…）
                    $types[$type instanceof \ReflectionNamedType ? $type->getName() : (string) $type] = true;

                    if ($type->allowsNull()) {
                        $types['null'] = true;
                    }
                }

                if ($ignore_compatible) {
                    $types = array_filter($types, function ($type) use ($types) {
                        // いくつか互換のある内包疑似型が存在する（iterable は array を内包するし、 bool は false を内包する）
                        foreach (self::PSEUDO[$type] ?? [] as $parent) {
                            if (isset($types[$parent])) {
                                return false;
                            }
                        }
                        // さらに object 疑似型は全てのクラス名を内包する
                        if (isset($types['object']) && !isset(self::PSEUDO[$type])) {
                            return false;
                        }
                        return true;
                    }, ARRAY_FILTER_USE_KEY);
                }

                if ($sort) {
                    static $orders = null;
                    $orders ??= array_flip(array_keys(self::PSEUDO));
                    uksort($types, function ($a, $b) use ($orders) {
                        $issetA = isset($orders[$a]);
                        $issetB = isset($orders[$b]);
                        switch (true) {
                            case $issetA && $issetB:   // 共に疑似型
                                return $orders[$a] - $orders[$b];
                            case !$issetA && !$issetB: // 共にクラス名
                                return strcasecmp($a, $b);
                            case !$issetA && $issetB:  // A だけがクラス名
                                return -1;
                            case $issetA && !$issetB:  // B だけがクラス名
                                return +1;
                        }
                    });
                }
                return array_keys($types);
            }
        };
    }
}

assert(!function_exists('ryunosuke\\NightDragon\\concat') || (new \ReflectionFunction('ryunosuke\\NightDragon\\concat'))->isUserDefined());
if (!function_exists('ryunosuke\\NightDragon\\concat')) {
    /**
     * strcat の空文字回避版
     *
     * 基本は strcat と同じ。ただし、**引数の内1つでも空文字を含むなら空文字を返す**。
     * さらに*引数の内1つでも null を含むなら null を返す**。
     *
     * 「プレフィックスやサフィックスを付けたいんだけど、空文字の場合はそのままで居て欲しい」という状況はまれによくあるはず。
     * コードで言えば `strlen($string) ? 'prefix-' . $string : '';` のようなもの。
     * 可変引数なので 端的に言えば mysql の CONCAT みたいな動作になる。
     *
     * ```php
     * that(concat('prefix-', 'middle', '-suffix'))->isSame('prefix-middle-suffix');
     * that(concat('prefix-', '', '-suffix'))->isSame('');
     * that(concat('prefix-', null, '-suffix'))->isSame(null);
     * ```
     *
     * @package ryunosuke\Functions\Package\strings
     *
     * @param ?string ...$variadic 結合する文字列（可変引数）
     * @return ?string 結合した文字列
     */
    function concat(...$variadic)
    {
        if (count(array_filter($variadic, 'is_null')) > 0) {
            return null;
        }
        $result = '';
        foreach ($variadic as $s) {
            if (strlen($s) === 0) {
                return '';
            }
            $result .= $s;
        }
        return $result;
    }
}

assert(!function_exists('ryunosuke\\NightDragon\\namespace_split') || (new \ReflectionFunction('ryunosuke\\NightDragon\\namespace_split'))->isUserDefined());
if (!function_exists('ryunosuke\\NightDragon\\namespace_split')) {
    /**
     * 文字列を名前空間とローカル名に区切ってタプルで返す
     *
     * class_namespace/class_shorten や function_shorten とほぼ同じだが下記の違いがある。
     *
     * - あくまで文字列として処理する
     *     - 例えば class_namespace は get_class されるが、この関数は（いうなれば） strval される
     * - \\ を trim しないし、特別扱いもしない
     *     - `ns\\hoge` と `\\ns\\hoge` で返り値が微妙に異なる
     *     - `ns\\` のような場合は名前空間だけを返す
     *
     * Example:
     * ```php
     * that(namespace_split('ns\\hoge'))->isSame(['ns', 'hoge']);
     * that(namespace_split('hoge'))->isSame(['', 'hoge']);
     * that(namespace_split('ns\\'))->isSame(['ns', '']);
     * that(namespace_split('\\hoge'))->isSame(['', 'hoge']);
     * ```
     *
     * @package ryunosuke\Functions\Package\strings
     *
     * @param string $string 対象文字列
     * @return array [namespace, localname]
     */
    function namespace_split(?string $string)
    {
        $pos = strrpos($string, '\\');
        if ($pos === false) {
            return ['', $string];
        }
        return [substr($string, 0, $pos), substr($string, $pos + 1)];
    }
}

assert(!function_exists('ryunosuke\\NightDragon\\str_chop') || (new \ReflectionFunction('ryunosuke\\NightDragon\\str_chop'))->isUserDefined());
if (!function_exists('ryunosuke\\NightDragon\\str_chop')) {
    /**
     * 先頭・末尾の指定文字列を削ぎ落とす
     *
     * Example:
     * ```php
     * // 文字列からパス文字列と拡張子を削ぎ落とす
     * $PATH = '/path/to/something';
     * that(str_chop("$PATH/hoge.php", "$PATH/", '.php'))->isSame('hoge');
     * ```
     *
     * @package ryunosuke\Functions\Package\strings
     *
     * @param string $string 対象文字列
     * @param string $prefix 削ぎ落とす先頭文字列
     * @param string $suffix 削ぎ落とす末尾文字列
     * @param bool $case_insensitivity 大文字小文字を無視するか
     * @return string 削ぎ落とした文字列
     */
    function str_chop(?string $string, ?string $prefix = '', ?string $suffix = '', $case_insensitivity = false)
    {
        $pattern = [];
        if (strlen($prefix)) {
            $pattern[] = '(\A' . preg_quote($prefix, '#') . ')';
        }
        if (strlen($suffix)) {
            $pattern[] = '(' . preg_quote($suffix, '#') . '\z)';
        }
        $flag = 'u' . ($case_insensitivity ? 'i' : '');
        return preg_replace('#' . implode('|', $pattern) . '#' . $flag, '', $string);
    }
}

assert(!function_exists('ryunosuke\\NightDragon\\str_exists') || (new \ReflectionFunction('ryunosuke\\NightDragon\\str_exists'))->isUserDefined());
if (!function_exists('ryunosuke\\NightDragon\\str_exists')) {
    /**
     * 指定文字列を含むか返す
     *
     * Example:
     * ```php
     * that(str_exists('abc', 'b'))->isTrue();
     * that(str_exists('abc', 'B', true))->isTrue();
     * that(str_exists('abc', ['b', 'x'], false, false))->isTrue();
     * that(str_exists('abc', ['b', 'x'], false, true))->isFalse();
     * ```
     *
     * @package ryunosuke\Functions\Package\strings
     *
     * @param string $haystack 対象文字列
     * @param string|array $needle 調べる文字列
     * @param bool $case_insensitivity 大文字小文字を無視するか
     * @param bool $and_flag すべて含む場合に true を返すか
     * @return bool $needle を含むなら true
     */
    function str_exists(?string $haystack, $needle, $case_insensitivity = false, $and_flag = false)
    {
        if (!is_array($needle)) {
            $needle = [$needle];
        }

        $needle = array_filter(array_map('strval', $needle), 'strlen');

        foreach ($needle as $str) {
            $pos = $case_insensitivity ? stripos($haystack, $str) : strpos($haystack, $str);
            if ($and_flag && $pos === false) {
                return false;
            }
            if (!$and_flag && $pos !== false) {
                return true;
            }
        }
        return !!$and_flag;
    }
}

assert(!function_exists('ryunosuke\\NightDragon\\str_lchop') || (new \ReflectionFunction('ryunosuke\\NightDragon\\str_lchop'))->isUserDefined());
if (!function_exists('ryunosuke\\NightDragon\\str_lchop')) {
    /**
     * 先頭の指定文字列を削ぎ落とす
     *
     * Example:
     * ```php
     * // 文字列からパス文字列を削ぎ落とす
     * $PATH = '/path/to/something';
     * that(str_lchop("$PATH/hoge.php", "$PATH/"))->isSame('hoge.php');
     * ```
     *
     * @package ryunosuke\Functions\Package\strings
     *
     * @param string $string 対象文字列
     * @param string $prefix 削ぎ落とす先頭文字列
     * @param bool $case_insensitivity 大文字小文字を無視するか
     * @return string 削ぎ落とした文字列
     */
    function str_lchop(?string $string, ?string $prefix, $case_insensitivity = false)
    {
        return str_chop($string, $prefix, '', $case_insensitivity);
    }
}

assert(!function_exists('ryunosuke\\NightDragon\\str_quote') || (new \ReflectionFunction('ryunosuke\\NightDragon\\str_quote'))->isUserDefined());
if (!function_exists('ryunosuke\\NightDragon\\str_quote')) {
    /**
     * 文字列をダブルクォート文字列に変換する
     *
     * 文字ではうまく表現できないが、例えば「本当の改行」が \n になり、「本当のタブ文字」が \t になる。
     * コントロール文字は "\code" 形式のようになる。
     * 「得られた文字列は eval すると元に戻る」とでも言えばいいか。
     *
     * 制御文字をそのまま出力するとまずい状況が稀によくある（特に行指向媒体への改行文字）。
     * この関数を通せば php の文字列の体裁を保ったまま1行化できる。
     * 端的に言えば var_export の文字列特化版。
     *
     * 挙動は $options である程度制御可能。
     * 各 $options は原則的に文字のマップか true を渡す（true の場合はデフォルトが使用される）。
     * 一部、それ以外の値・型に対応しているものもある。
     *
     * - escape-character: 制御文字のうち、明確なエスケープシーケンスが存在する場合はそれを使用する
     *   - control-character にオーバーラップするがこちらが優先される
     * - control-character: 00 ～ 1F+7F の制御文字を \code 形式にする
     *   - 文字列で "oct", "hex", "HEX" も指定できる。その場合それぞれ \oct, \xhex, \xHEX 形式になる
     * - special-character: ダブルクオート内の文字列が文字列であるための変換を行う
     *   - 原則的にデフォルトに任せて指定すべきではない
     *
     * Example:
     * ```php
     * // （非常に分かりにくいが）下記のように変換される
     * that(str_quote("\$a\nb\rc\x00"))->isSame("\"\\\$a\\nb\\rc\\0\"");
     * // 文字としての意味は一緒であり要するに表現形式の違いなので、php の世界で eval すれば元の文字列に戻る
     * that(eval('return ' . str_quote("\$a\nb\rc\x00") . ';'))->isSame("\$a\nb\rc\x00");
     * ```
     *
     * @package ryunosuke\Functions\Package\strings
     *
     * @param string $string 対象文字列
     * @param array $options オプション配列
     * @return string クォート文字列
     */
    function str_quote(string $string, array $options = []): string
    {
        $options += [
            'escape-character'  => true,
            'control-character' => true,
            'special-character' => true,
            'heredoc'           => '',
            'nowdoc'            => '',
            'indent'            => 0,
        ];

        assert(!($options['heredoc'] && $options['nowdoc']));

        // nowdoc にエスケープは存在しないのでそのまま埋め込む（その結果壊れてもこの関数の責務ではない）
        if (strlen($options['nowdoc'])) {
            $indent = str_repeat(" ", $options['indent']);
            $string = preg_replace('#(\R)#u', '$1' . $indent, $string);
            return "<<<'{$options['nowdoc']}'\n{$indent}{$string}\n{$indent}{$options['nowdoc']}";
        }

        // @see https://www.php.net/manual/ja/language.types.string.php#language.types.string.syntax.double
        $special_chars = [
            '\\' => '\\\\', // バックスラッシュ
            '"'  => '\\"',  // 二重引用符
            '$'  => '\\$',  // ドル記号
        ];
        $escape_chars = [
            "\11" => '\\t', // 水平タブ (HT またはアスキーの 0x09 (9))
            "\12" => '\\n', // ラインフィード (LF またはアスキーの 0x0A (10))
            "\13" => '\\v', // 垂直タブ (VT またはアスキーの 0x0B (11))
            "\14" => '\\f', // フォームフィード (FF またはアスキーの 0x0C (12))
            "\15" => '\\r', // キャリッジリターン (CR またはアスキーの 0x0D (13))
            "\33" => '\\e', // エスケープ (ESC あるいはアスキーの 0x1B (27))
        ];
        $control_chars = [
            "\0"   => "\\0",
            "\1"   => "\\1",
            "\2"   => "\\2",
            "\3"   => "\\3",
            "\4"   => "\\4",
            "\5"   => "\\5",
            "\6"   => "\\6",
            "\7"   => "\\7",
            "\10"  => "\\10",
            "\11"  => "\\11",
            "\12"  => "\\12",
            "\13"  => "\\13",
            "\14"  => "\\14",
            "\15"  => "\\15",
            "\16"  => "\\16",
            "\17"  => "\\17",
            "\20"  => "\\20",
            "\21"  => "\\21",
            "\22"  => "\\22",
            "\23"  => "\\23",
            "\24"  => "\\24",
            "\25"  => "\\25",
            "\26"  => "\\26",
            "\27"  => "\\27",
            "\30"  => "\\30",
            "\31"  => "\\31",
            "\32"  => "\\32",
            "\33"  => "\\33",
            "\34"  => "\\34",
            "\35"  => "\\35",
            "\36"  => "\\36",
            "\37"  => "\\37",
            "\177" => "\\177",
        ];

        // heredoc 用の特殊処理（タイプ可能な文字はエスケープしなくてもよいだろう）
        if (strlen($options['heredoc'])) {
            $control_chars = array_diff_key($control_chars, $escape_chars);
            $escape_chars = [];
            unset($special_chars['"']);
        }

        $charmap = [];
        if ($options['special-character']) {
            $charmap += is_array($options['special-character']) ? $options['special-character'] : $special_chars;
        }
        if ($options['escape-character']) {
            $charmap += is_array($options['escape-character']) ? $options['escape-character'] : $escape_chars;
        }
        if ($options['control-character']) {
            if ($options['control-character'] === 'oct') {
                // デフォで oct にしてあるので変換不要
                assert(end($control_chars) === "\\177");
            }
            if ($options['control-character'] === 'hex') {
                $control_chars = array_map(fn($v) => sprintf('\\x%02x', octdec(trim($v, '\\'))), $control_chars);
            }
            if ($options['control-character'] === 'HEX') {
                $control_chars = array_map(fn($v) => sprintf('\\x%02X', octdec(trim($v, '\\'))), $control_chars);
            }
            $charmap += is_array($options['control-character']) ? $options['control-character'] : $control_chars;
        }

        $string = strtr($string, $charmap);

        if (strlen($options['heredoc'])) {
            $indent = str_repeat(" ", $options['indent']);
            $string = preg_replace('#(\R)#u', '$1' . $indent, $string);
            return "<<<{$options['heredoc']}\n{$indent}{$string}\n{$indent}{$options['heredoc']}";
        }

        return '"' . $string . '"';
    }
}

assert(!function_exists('ryunosuke\\NightDragon\\base64url_encode') || (new \ReflectionFunction('ryunosuke\\NightDragon\\base64url_encode'))->isUserDefined());
if (!function_exists('ryunosuke\\NightDragon\\base64url_encode')) {
    /**
     * url safe な base64_encode
     *
     * れっきとした RFC があるのかは分からないが '+' => '-', '/' => '_' がデファクトだと思うのでそのようにしてある。
     * パディングの = も外す。
     *
     * @package ryunosuke\Functions\Package\url
     *
     * @param string $string 変換元文字列
     * @return string base64url 文字列
     */
    function base64url_encode($string)
    {
        return rtrim(strtr(base64_encode($string), ['+' => '-', '/' => '_']), '=');
    }
}

assert(!function_exists('ryunosuke\\NightDragon\\function_configure') || (new \ReflectionFunction('ryunosuke\\NightDragon\\function_configure'))->isUserDefined());
if (!function_exists('ryunosuke\\NightDragon\\function_configure')) {
    /**
     * 本ライブラリの設定を行う
     *
     * 各関数の挙動を変えたり、デフォルトオプションを設定できる。
     *
     * @package ryunosuke\Functions\Package\utility
     *
     * @param array|?string $option 設定。文字列指定時はその値を返す
     * @return array|string 設定値
     */
    function function_configure($option)
    {
        static $config = [];

        // default
        $config['cachedir'] ??= sys_get_temp_dir() . DIRECTORY_SEPARATOR . 'rf' . DIRECTORY_SEPARATOR . strtr(__NAMESPACE__, ['\\' => '%']);
        $config['storagedir'] ??= DIRECTORY_SEPARATOR === '/' ? '/var/tmp/rf/' . strtr(__NAMESPACE__, ['\\' => '%']) : (getenv('ALLUSERSPROFILE') ?: sys_get_temp_dir()) . '\\rf\\' . strtr(__NAMESPACE__, ['\\' => '%']);
        $config['placeholder'] ??= '';
        $config['var_stream'] ??= 'VarStreamV010000';
        $config['memory_stream'] ??= 'MemoryStreamV010000';
        $config['array.variant'] ??= false;
        $config['chain.version'] ??= 2;
        $config['chain.nullsafe'] ??= false;
        $config['process.autoload'] ??= [];
        $config['datetime.class'] ??= \DateTimeImmutable::class;

        // setting
        if (is_array($option)) {
            foreach ($option as $name => $entry) {
                $option[$name] = $config[$name] ?? null;
                switch ($name) {
                    default:
                        $config[$name] = $entry;
                        break;
                    case 'cachedir':
                    case 'storagedir':
                        $entry ??= $config[$name];
                        if (!file_exists($entry)) {
                            @mkdir($entry, 0777 & (~umask()), true);
                        }
                        $config[$name] = realpath($entry);
                        break;
                    case 'placeholder':
                        if (strlen($entry)) {
                            $entry = ltrim($entry[0] === '\\' ? $entry : __NAMESPACE__ . '\\' . $entry, '\\');
                            if (!defined($entry)) {
                                define($entry, tmpfile() ?: [] ?: '' ?: 0.0 ?: null ?: false);
                            }
                            if (!is_resourcable(constant($entry))) {
                                // もしリソースじゃないと一意性が保てず致命的になるので例外を投げる
                                throw new \RuntimeException('placeholder is not resource'); // @codeCoverageIgnore
                            }
                            $config[$name] = $entry;
                        }
                        break;
                }
            }
            return $option;
        }

        // getting
        if ($option === null) {
            return $config;
        }
        if (is_string($option)) {
            switch ($option) {
                default:
                    return $config[$option] ?? null;
                case 'cachedir':
                case 'storagedir':
                    $dirname = $config[$option];
                    if (!file_exists($dirname)) {
                        @mkdir($dirname, 0777 & (~umask()), true); // @codeCoverageIgnore
                    }
                    return realpath($dirname);
            }
        }

        throw new \InvalidArgumentException(sprintf('$option is unknown type(%s)', gettype($option)));
    }
}

assert(!function_exists('ryunosuke\\NightDragon\\json_storage') || (new \ReflectionFunction('ryunosuke\\NightDragon\\json_storage'))->isUserDefined());
if (!function_exists('ryunosuke\\NightDragon\\json_storage')) {
    /**
     * キーが json 化されてファイルシステムに永続化される ArrayAccess を返す
     *
     * 非常にシンプルで PSR-16 も実装せず、クリア手段も（基本的には）存在しない。
     * ArrayAccess なので `$storage['hoge'] ??= something()` として使うのがほぼ唯一の利用法。
     * その仕様・利用上、値として null を使用することはできない（使用した場合の動作は未定義とする）。
     *
     * キーに指定できるのは json_encode 可能なもののみ。
     * 値に指定できるのは var_export 可能なもののみ。
     * 上記以外を与えたときの動作は未定義。
     * TTL を指定すると次回読み込み時に期限切れをチェックし、切れていた場合 null を返す。
     * 一度読み込まれればそのリクエスト中は期限切れになることはない。
     *
     * 得てして簡単な関数・メソッドのメモ化や内部的なキャッシュに使用する。
     *
     * Example:
     * ```php
     * // ??= を使えば「無かったら値を、有ったらそれを」を単純に実現できる
     * $storage = json_storage();
     * that($storage['key'] ??= (fn() => 123)())->is(123);
     * that($storage['key'] ??= (fn() => 456)())->is(123);
     * // 引数に与えた prefix で別空間になる
     * $storage = json_storage('other');
     * that($storage['key'] ??= (fn() => 789)())->is(789);
     * ```
     *
     * @package ryunosuke\Functions\Package\utility
     *
     * @param string $directory 永続化ディレクトリ
     * @param int $ttl TTL
     * @return \ArrayObject
     */
    function json_storage(string $prefix = 'global', int $ttl = PHP_INT_MAX)
    {
        $cachedir = function_configure('cachedir') . '/' . strtr(__FUNCTION__, ['\\' => '%']);
        if (!file_exists($cachedir)) {
            @mkdir($cachedir, 0777, true);
        }

        static $objects = [];
        $objects[$prefix] ??= new class("$cachedir/" . strtr($prefix, ['\\' => '%', '/' => '-'])) extends \ArrayObject {
            public int $defaultTtl = PHP_INT_MAX;

            public function __construct(private string $directory)
            {
                parent::__construct();
            }

            public function offsetExists(mixed $key): bool
            {
                return $this->offsetGet($key) !== null;
            }

            public function offsetGet(mixed $key): mixed
            {
                $json = $this->json($key);

                // 有るならそれでよい
                if (parent::offsetExists($json)) {
                    return parent::offsetGet($json);
                }

                // 無くてもストレージにある可能性がある
                $filename = $this->filename($json);
                clearstatcache(true, $filename);
                if (file_exists($filename)) {
                    [$k, $v, $t] = include $filename;
                    // TTL 兼 hash 化してるので万が一競合すると異なるデータを返してしまう
                    if (($k !== $key) || ((time() - $t) >= $this->defaultTtl)) {
                        return null;
                    }
                    // ストレージに有ったら内部キャッシュしてそれを使う
                    parent::offsetSet($json, $v);
                    return $v;
                }

                return null;
            }

            public function offsetSet(mixed $key, mixed $value): void
            {
                $json = $this->json($key);

                // 値が変化したらストレージにも保存
                if (!parent::offsetExists($json) || parent::offsetGet($json) !== $value) {
                    assert(is_exportable($value));
                    $filename = $this->filename($json);
                    if ($value === null) {
                        opcache_invalidate($filename, true);
                        @unlink($filename);
                    }
                    else {
                        file_put_contents($filename, '<?php return ' . var_export([$key, $value, time()], true) . ';', LOCK_EX);
                    }
                }

                parent::offsetSet($json, $value);
            }

            public function offsetUnset(mixed $key): void
            {
                $this->offsetSet($key, null);
            }

            private function json(mixed $data): string
            {
                assert((function () use ($data) {
                    $tmp = [$data];
                    array_walk_recursive($tmp, function ($value) {
                        if (is_resourcable($value)) {
                            throw new \Exception("\$value is resource");
                        }
                        if (is_object($value) && (!$value instanceof \JsonSerializable && get_class($value) !== \stdClass::class)) {
                            throw new \Exception("\$value is not JsonSerializable");
                        }
                    });
                    return true;
                })());
                return json_encode($data, JSON_UNESCAPED_UNICODE | JSON_THROW_ON_ERROR);
            }

            private function filename(string $json): string
            {
                $filename = base64url_encode(implode("\n", [
                    hash('fnv164', $json, true),
                    hash('crc32', $json, true),
                ]));
                return "{$this->directory}-$filename.php-cache";
            }

            /** @noinspection PhpUnusedPrivateMethodInspection */
            private function debug($closure)
            {
                return $closure->call($this);
            }
        };
        $objects[$prefix]->defaultTtl = $ttl;
        return $objects[$prefix];
    }
}

assert(!function_exists('ryunosuke\\NightDragon\\arrayval') || (new \ReflectionFunction('ryunosuke\\NightDragon\\arrayval'))->isUserDefined());
if (!function_exists('ryunosuke\\NightDragon\\arrayval')) {
    /**
     * array キャストの関数版
     *
     * intval とか strval とかの array 版。
     * ただキャストするだけだが、関数なのでコールバックとして使える。
     *
     * $recursive を true にすると再帰的に適用する（デフォルト）。
     * 入れ子オブジェクトを配列化するときなどに使える。
     *
     * Example:
     * ```php
     * // キャストなので基本的には配列化される
     * that(arrayval(123))->isSame([123]);
     * that(arrayval('str'))->isSame(['str']);
     * that(arrayval([123]))->isSame([123]); // 配列は配列のまま
     *
     * // $recursive = false にしない限り再帰的に適用される
     * $stdclass = (object) ['key' => 'val'];
     * that(arrayval([$stdclass], true))->isSame([['key' => 'val']]); // true なので中身も配列化される
     * that(arrayval([$stdclass], false))->isSame([$stdclass]);       // false なので中身は変わらない
     * ```
     *
     * @package ryunosuke\Functions\Package\var
     *
     * @param mixed $var array 化する値
     * @param bool $recursive 再帰的に行うなら true
     * @return array array 化した配列
     */
    function arrayval($var, $recursive = true)
    {
        // return json_decode(json_encode($var), true);

        // 無駄なループを回したくないので非再帰で配列の場合はそのまま返す
        if (!$recursive && is_array($var)) {
            return $var;
        }

        if (is_primitive($var)) {
            return (array) $var;
        }

        $result = [];
        foreach ($var as $k => $v) {
            if ($recursive && !is_primitive($v)) {
                $v = arrayval($v, $recursive);
            }
            $result[$k] = $v;
        }
        return $result;
    }
}

assert(!function_exists('ryunosuke\\NightDragon\\is_arrayable') || (new \ReflectionFunction('ryunosuke\\NightDragon\\is_arrayable'))->isUserDefined());
if (!function_exists('ryunosuke\\NightDragon\\is_arrayable')) {
    /**
     * 変数が配列アクセス可能か調べる
     *
     * Example:
     * ```php
     * that(is_arrayable([]))->isTrue();
     * that(is_arrayable(new \ArrayObject()))->isTrue();
     * that(is_arrayable(new \stdClass()))->isFalse();
     * ```
     *
     * @package ryunosuke\Functions\Package\var
     *
     * @param mixed $var 調べる値
     * @return bool 配列アクセス可能なら true
     */
    function is_arrayable($var)
    {
        return is_array($var) || $var instanceof \ArrayAccess;
    }
}

assert(!function_exists('ryunosuke\\NightDragon\\is_empty') || (new \ReflectionFunction('ryunosuke\\NightDragon\\is_empty'))->isUserDefined());
if (!function_exists('ryunosuke\\NightDragon\\is_empty')) {
    /**
     * 値が空か検査する
     *
     * `empty` とほぼ同じ。ただし
     *
     * - string: "0"
     * - countable でない object
     * - countable である object で count() > 0
     *
     * は false 判定する。
     * ただし、 $empty_stcClass に true を指定すると「フィールドのない stdClass」も true を返すようになる。
     * これは stdClass の立ち位置はかなり特殊で「フィールドアクセスできる組み込み配列」のような扱いをされることが多いため。
     * （例えば `json_decode('{}')` は stdClass を返すが、このような状況は空判定したいことが多いだろう）。
     *
     * なお、関数の仕様上、未定義変数を true 判定することはできない。
     * 未定義変数をチェックしたい状況は大抵の場合コードが悪いが `$array['key1']['key2']` を調べたいことはある。
     * そういう時には使えない（?? する必要がある）。
     *
     * 「 `if ($var) {}` で十分なんだけど "0" が…」という状況はまれによくあるはず。
     *
     * Example:
     * ```php
     * // この辺は empty と全く同じ
     * that(is_empty(null))->isTrue();
     * that(is_empty(false))->isTrue();
     * that(is_empty(0))->isTrue();
     * that(is_empty(''))->isTrue();
     * // この辺だけが異なる
     * that(is_empty('0'))->isFalse();
     * // 第2引数に true を渡すと空の stdClass も empty 判定される
     * $stdclass = new \stdClass();
     * that(is_empty($stdclass, true))->isTrue();
     * // フィールドがあれば empty ではない
     * $stdclass->hoge = 123;
     * that(is_empty($stdclass, true))->isFalse();
     * ```
     *
     * @package ryunosuke\Functions\Package\var
     *
     * @param mixed $var 判定する値
     * @param bool $empty_stdClass 空の stdClass を空とみなすか
     * @return bool 空なら true
     */
    function is_empty($var, $empty_stdClass = false)
    {
        // object は is_countable 次第
        if (is_object($var)) {
            // が、 stdClass だけは特別扱い（stdClass は継承もできるので、クラス名で判定する（継承していたらそれはもう stdClass ではないと思う））
            if ($empty_stdClass && get_class($var) === 'stdClass') {
                return !(array) $var;
            }
            if (is_countable($var)) {
                return !count($var);
            }
            return false;
        }

        // "0" は false
        if ($var === '0') {
            return false;
        }

        // 上記以外は empty に任せる
        return empty($var);
    }
}

assert(!function_exists('ryunosuke\\NightDragon\\is_exportable') || (new \ReflectionFunction('ryunosuke\\NightDragon\\is_exportable'))->isUserDefined());
if (!function_exists('ryunosuke\\NightDragon\\is_exportable')) {
    /**
     * 値が var_export で出力可能か検査する
     *
     * 「出力可能」とは「意味のある出力」を意味する。
     * 例えば set_state のないオブジェクトはエラーなく set_state コール形式で出力されるが意味のある出力ではない。
     * リソース型はエラーなく NULL で出力されるが意味のある出力ではない。
     * 循環参照は出力できるものの warning が出てかつ循環は切れるため意味のある出力ではない。
     *
     * Example:
     * ```php
     * that(is_primitive(null))->isTrue();
     * that(is_primitive(false))->isTrue();
     * that(is_primitive(123))->isTrue();
     * that(is_primitive(STDIN))->isTrue();
     * that(is_primitive(new \stdClass))->isFalse();
     * that(is_primitive(['array']))->isFalse();
     * ```
     *
     * @package ryunosuke\Functions\Package\var
     *
     * @param mixed $var 調べる値
     * @return bool 出力可能なら true
     */
    function is_exportable($var): bool
    {
        // スカラー/NULL は OK
        if (is_scalar($var) || is_null($var)) {
            return true;
        }

        // リソース型の変数は、この関数ではエクスポートする事ができません
        if (is_resourcable($var)) {
            return false;
        }

        // var_export() では循環参照を扱うことができません
        if (is_recursive($var)) {
            return false;
        }

        // 配列に制限はない。それゆえに全要素を再帰的に見なければならない
        if (is_array($var)) {
            foreach ($var as $v) {
                if (!is_exportable($v)) {
                    return false;
                }
            }
            return true;
        }

        if (is_object($var)) {
            // 無名クラスは非常に特殊で、出力は class@anonymous{filename}:123$456::__set_state(...) のようになる
            // set_state さえ実装してれば復元可能に思えるが php コードとして不正なのでそのまま実行するとシンタックスエラーになる
            // 'class@anonymous{filename}:123$456'::__set_state(...) のようにクオートすれば実行可能になるが、それは標準 var_export の動作ではない
            // 復元する側がクオートして読み込み…とすれば復元可能だが、そもそもクラスがロードされている保証もない
            // これらのことを考慮するなら「意味のある出力」ではないとみなした方が手っ取り早い
            if ((new \ReflectionClass($var))->isAnonymous()) {
                return false;
            }
            // var_export() が生成する PHP を評価できるようにするためには、処理対象のすべてのオブジェクトがマジックメソッド __set_state を実装している必要があります
            if (method_exists($var, '__set_state')) {
                return true;
            }
            // これの唯一の例外は stdClass です。 stdClass は、配列をオブジェクトにキャストした形でエクスポートされます
            if (get_class($var) === \stdClass::class) {
                return true;
            }
            // マニュアルに記載はないが enum は export できる
            if ($var instanceof \UnitEnum) {
                return true;
            }
            return false;
        }
    }
}

assert(!function_exists('ryunosuke\\NightDragon\\is_primitive') || (new \ReflectionFunction('ryunosuke\\NightDragon\\is_primitive'))->isUserDefined());
if (!function_exists('ryunosuke\\NightDragon\\is_primitive')) {
    /**
     * 値が複合型でないか検査する
     *
     * 「複合型」とはオブジェクトと配列のこと。
     * つまり
     *
     * - is_scalar($var) || is_null($var) || is_resource($var)
     *
     * と同義（!is_array($var) && !is_object($var) とも言える）。
     *
     * Example:
     * ```php
     * that(is_primitive(null))->isTrue();
     * that(is_primitive(false))->isTrue();
     * that(is_primitive(123))->isTrue();
     * that(is_primitive(STDIN))->isTrue();
     * that(is_primitive(new \stdClass))->isFalse();
     * that(is_primitive(['array']))->isFalse();
     * ```
     *
     * @package ryunosuke\Functions\Package\var
     *
     * @param mixed $var 調べる値
     * @return bool 複合型なら false
     */
    function is_primitive($var)
    {
        return is_scalar($var) || is_null($var) || is_resourcable($var);
    }
}

assert(!function_exists('ryunosuke\\NightDragon\\is_recursive') || (new \ReflectionFunction('ryunosuke\\NightDragon\\is_recursive'))->isUserDefined());
if (!function_exists('ryunosuke\\NightDragon\\is_recursive')) {
    /**
     * 変数が再帰参照を含むか調べる
     *
     * Example:
     * ```php
     * // 配列の再帰
     * $array = [];
     * $array['recursive'] = &$array;
     * that(is_recursive($array))->isTrue();
     * // オブジェクトの再帰
     * $object = new \stdClass();
     * $object->recursive = $object;
     * that(is_recursive($object))->isTrue();
     * ```
     *
     * @package ryunosuke\Functions\Package\var
     *
     * @param mixed $var 調べる値
     * @return bool 再帰参照を含むなら true
     */
    function is_recursive($var)
    {
        $core = function ($var, $parents) use (&$core) {
            // 複合型でないなら間違いなく false
            if (is_primitive($var)) {
                return false;
            }

            // 「親と同じ子」は再帰以外あり得ない。よって === で良い（オブジェクトに関してはそもそも等値比較で絶対に一致しない）
            // sql_object_hash とか serialize でキーに保持して isset の方が速いか？
            // → ベンチ取ったところ in_array の方が10倍くらい速い。多分生成コストに起因
            // raw な比較であれば瞬時に比較できるが、isset だと文字列化が必要でかなり無駄が生じていると考えられる
            foreach ($parents as $parent) {
                if ($parent === $var) {
                    return true;
                }
            }

            // 全要素を再帰的にチェック
            $parents[] = $var;
            foreach ($var as $v) {
                if ($core($v, $parents)) {
                    return true;
                }
            }
            return false;
        };
        return $core($var, []);
    }
}

assert(!function_exists('ryunosuke\\NightDragon\\is_resourcable') || (new \ReflectionFunction('ryunosuke\\NightDragon\\is_resourcable'))->isUserDefined());
if (!function_exists('ryunosuke\\NightDragon\\is_resourcable')) {
    /**
     * 閉じたリソースでも true を返す is_resource
     *
     * マニュアル（ https://www.php.net/manual/ja/function.is-resource.php ）に記載の通り、 isresource は閉じたリソースで false を返す。
     * リソースはリソースであり、それでは不便なこともあるので、閉じていようとリソースなら true を返す関数。
     *
     * Example:
     * ```php
     * // 閉じたリソースを用意
     * $resource = tmpfile();
     * fclose($resource);
     * // is_resource は false を返すが・・・
     * that(is_resource($resource))->isFalse();
     * // is_resourcable は true を返す
     * that(is_resourcable($resource))->isTrue();
     * ```
     *
     * @package ryunosuke\Functions\Package\var
     *
     * @param mixed $var 調べる値
     * @return bool リソースなら true
     */
    function is_resourcable($var)
    {
        if (is_resource($var)) {
            return true;
        }
        // もっといい方法があるかもしれないが、簡単に調査したところ gettype するしか術がないような気がする
        if (strpos(gettype($var), 'resource') === 0) {
            return true;
        }
        return false;
    }
}

assert(!function_exists('ryunosuke\\NightDragon\\is_stringable') || (new \ReflectionFunction('ryunosuke\\NightDragon\\is_stringable'))->isUserDefined());
if (!function_exists('ryunosuke\\NightDragon\\is_stringable')) {
    /**
     * 変数が文字列化できるか調べる
     *
     * 「配列」「__toString を持たないオブジェクト」が false になる。
     * （厳密に言えば配列は "Array" になるので文字列化できるといえるがここでは考えない）。
     *
     * Example:
     * ```php
     * // こいつらは true
     * that(is_stringable(null))->isTrue();
     * that(is_stringable(true))->isTrue();
     * that(is_stringable(3.14))->isTrue();
     * that(is_stringable(STDOUT))->isTrue();
     * that(is_stringable(new \Exception()))->isTrue();
     * // こいつらは false
     * that(is_stringable(new \ArrayObject()))->isFalse();
     * that(is_stringable([1, 2, 3]))->isFalse();
     * ```
     *
     * @package ryunosuke\Functions\Package\var
     *
     * @param mixed $var 調べる値
     * @return bool 文字列化できるなら true
     */
    function is_stringable($var)
    {
        if (is_array($var)) {
            return false;
        }
        if (is_object($var) && !method_exists($var, '__toString')) {
            return false;
        }
        return true;
    }
}

assert(!function_exists('ryunosuke\\NightDragon\\var_export2') || (new \ReflectionFunction('ryunosuke\\NightDragon\\var_export2'))->isUserDefined());
if (!function_exists('ryunosuke\\NightDragon\\var_export2')) {
    /**
     * 組み込みの var_export をいい感じにしたもの
     *
     * 下記の点が異なる。
     *
     * - 配列は 5.4 以降のショートシンタックス（[]）で出力
     * - ただの配列は1行（[1, 2, 3]）でケツカンマなし、連想配列は桁合わせインデントでケツカンマあり
     * - 文字列はダブルクオート
     * - null は null（小文字）
     * - 再帰構造を渡しても警告がでない（さらに NULL ではなく `'*RECURSION*'` という文字列になる）
     * - 配列の再帰構造の出力が異なる（Example参照）
     *
     * Example:
     * ```php
     * // 単純なエクスポート
     * that(var_export2(['array' => [1, 2, 3], 'hash' => ['a' => 'A', 'b' => 'B', 'c' => 'C']], true))->isSame('[
     *     "array" => [1, 2, 3],
     *     "hash"  => [
     *         "a" => "A",
     *         "b" => "B",
     *         "c" => "C",
     *     ],
     * ]');
     * // 再帰構造を含むエクスポート（標準の var_export は形式が異なる。 var_export すれば分かる）
     * $rarray = [];
     * $rarray['a']['b']['c'] = &$rarray;
     * $robject = new \stdClass();
     * $robject->a = new \stdClass();
     * $robject->a->b = new \stdClass();
     * $robject->a->b->c = $robject;
     * that(var_export2(compact('rarray', 'robject'), true))->isSame('[
     *     "rarray"  => [
     *         "a" => [
     *             "b" => [
     *                 "c" => "*RECURSION*",
     *             ],
     *         ],
     *     ],
     *     "robject" => (object) [
     *         "a" => (object) [
     *             "b" => (object) [
     *                 "c" => "*RECURSION*",
     *             ],
     *         ],
     *     ],
     * ]');
     * ```
     *
     * @package ryunosuke\Functions\Package\var
     *
     * @param mixed $value 出力する値
     * @param bool|array $options オプション配列（var_export に寄せるため bool も受け付ける）
     * @return string|null $return=true の場合は出力せず結果を返す
     */
    function var_export2($value, $options = [])
    {
        if (!is_array($options)) {
            $options = [
                'return' => !!$options,
            ];
        }

        $options += [
            'minify' => false, // 短縮形で返す（実質的には情報を減らして1行で返す）
            'indent' => 4,     // インデントの空白数
            'return' => false, // 値を戻すか出力するか
        ];

        // 再帰用クロージャ
        $export = function ($value, $context, $nest = 0, $parents = []) use (&$export, $options) {
            // 再帰を検出したら *RECURSION* とする（処理に関しては is_recursive のコメント参照）
            foreach ($parents as $parent) {
                if ($parent === $value) {
                    return $export('*RECURSION*', 'recursion');
                }
            }

            $space = $options['minify'] ? "" : " ";
            $break = $options['minify'] ? "" : "\n";

            // 配列は連想判定したり再帰したり色々
            if (is_array($value)) {
                $spacer1 = str_repeat($space, ($nest + 1) * $options['indent']);
                $spacer2 = str_repeat($space, $nest * $options['indent']);

                $hashed = is_hasharray($value);

                // スカラー値のみで構成されているならシンプルな再帰
                if (!$hashed && array_and($value, fn(...$args) => is_primitive(...$args))) {
                    return '[' . implode(",$space", array_map(fn($v) => $export($v, 'array-value'), $value)) . ']';
                }

                // 連想配列はキーを含めて桁あわせ
                if ($hashed) {
                    $keys = array_map(fn($v) => $export($v, 'array-key'), array_combine($keys = array_keys($value), $keys));
                    $maxlen = max(array_map('strlen', $keys));
                }
                $kvl = '';
                $lastkey = array_key_last($value);
                $parents[] = $value;
                foreach ($value as $k => $v) {
                    $keystr = $hashed ? $keys[$k] . str_repeat($space, $maxlen - strlen($keys[$k])) . "$space=>$space" : '';
                    $kvl .= $spacer1 . $keystr . $export($v, 'array-value', $nest + 1, $parents) . ($k === $lastkey && $options['minify'] ? "" : ",") . "$break";
                }
                return "[$break{$kvl}{$spacer2}]";
            }
            // オブジェクトは単にプロパティを __set_state する文字列を出力する
            elseif (is_object($value)) {
                $parents[] = $value;
                $classname = get_class($value);
                if ($classname === \stdClass::class) {
                    return "(object)$space" . $export((array) $value, 'object', $nest, $parents);
                }
                return $classname . '::__set_state(' . $export(object_properties($value), 'object', $nest, $parents) . ')';
            }
            // 文字列はダブルクオート（場合によってはヒアドキュメント）
            elseif (is_string($value)) {
                // 列揃えのため配列のキーは常にダブルクォート
                if ($context === 'array-key') {
                    return str_quote($value);
                }
                // 改行を含むならヒアドキュメント
                if (!$options['minify'] && str_exists($value, ["\r", "\n"])) {
                    // ただし、改行文字だけの場合は除く（何らかの引数で改行文字だけを渡すシチュエーションはそれなりにあるのでヒアドキュメントだと冗長）
                    if (trim($value, "\r\n") !== '') {
                        return str_quote($value, [
                            'heredoc' => unique_string($value, 'TEXT', '_'),
                            'indent'  => $nest * $options['indent'],
                        ]);
                    }
                }
                return str_quote($value);
            }
            // null は小文字で居て欲しい
            elseif (is_null($value)) {
                return 'null';
            }
            // それ以外は標準に従う
            else {
                return var_export($value, true);
            }
        };

        // 結果を返したり出力したり
        $result = $export($value, null);
        if ($options['return']) {
            return $result;
        }
        echo $result, "\n";
    }
}

assert(!function_exists('ryunosuke\\NightDragon\\var_hash') || (new \ReflectionFunction('ryunosuke\\NightDragon\\var_hash'))->isUserDefined());
if (!function_exists('ryunosuke\\NightDragon\\var_hash')) {
    /**
     * 値に複数のハッシュアルゴリズムを適用させて結合して返す
     *
     * $data は何らかの方法で文字列化される（この「何らかの方法」は互換性を担保しない）。
     * 文字長がかなり増えるため、 $base64 に true を与えるとバイナリ変換してその結果を base64（url セーフ）して返す。
     * さらに false を与えると 16進数文字列で返し、 null を与えるとバイナリ文字列で返す。
     *
     * Example:
     * ```php
     * // 配列をハッシュ化する
     * that(var_hash(['a', 'b', 'c']))->isSame('7BDgx6NE2hkXAKtKzhpeJm6-mheMOQWNgrCe7768OiFeoWgA');
     * // オブジェクトをハッシュ化する
     * that(var_hash(new \ArrayObject(['a', 'b', 'c'])))->isSame('-zR2rZ58CzuYhhdHn1Oq90zkYSaxMS-dHUbmb0MTRM4gBpj2');
     * ```
     *
     * @package ryunosuke\Functions\Package\var
     *
     * @param mixed $var ハッシュ化する値
     * @param string[] $algos ハッシュアルゴリズム
     * @param ?bool $base64 結果を base64 化するか
     * @return string ハッシュ文字列
     */
    function var_hash($var, $algos = ['md5', 'sha1'], $base64 = true)
    {
        if (!is_string($var)) {
            $var = serialize($var);
        }

        $algos = arrayize($algos);
        assert($algos);

        $hash = '';
        foreach ($algos as $algo) {
            $hash .= hash($algo, "$var", $base64 !== false);
        }

        if ($base64 !== true) {
            return $hash;
        }

        return base64url_encode($hash);
    }
}

assert(!function_exists('ryunosuke\\NightDragon\\var_type') || (new \ReflectionFunction('ryunosuke\\NightDragon\\var_type'))->isUserDefined());
if (!function_exists('ryunosuke\\NightDragon\\var_type')) {
    /**
     * 値の型を取得する
     *
     * get_debug_type を少しだけ特殊化したもの。
     * 「デバッグ用の型」ではなく「コード化したときに埋め込みやすい型」が主目的。
     *
     * - object の場合は必ず \ が付く
     * - resource の場合はカッコ書き無しで 'resource'
     *
     * 無名クラスの場合は extends, implements の優先順位でその名前を使う。
     * 継承も実装もされていない場合は標準の get_class の結果を返す。
     *
     * phpdoc に true を渡すと array-shape 記法も有効になり下記のようになる。
     *
     * - 連想配列は想起した通り
     * - 連番配列は中身の和集合を取る
     *     - 中身がさらに配列なら再帰的に処理する
     *         - 有り無し混在は null 扱いになる
     * - 無名クラスは親クラス＋インターフェースを取る
     *     - 完全無名クラスは object になる
     *
     * phpdoc:true の場合の結果は互換性を考慮しない。
     *
     * Example:
     * ```php
     * // プリミティブ型は get_debug_type と同義
     * that(var_type(false))->isSame('bool');
     * that(var_type(123))->isSame('int');
     * that(var_type(3.14))->isSame('float');
     * that(var_type([1, 2, 3]))->isSame('array');
     * // リソースはなんでも resource
     * that(var_type(STDOUT))->isSame('resource');
     * // オブジェクトは型名を返す
     * that(var_type(new \stdClass))->isSame('\\stdClass');
     * that(var_type(new \Exception()))->isSame('\\Exception');
     * // 無名クラスは継承元の型名を返す（インターフェース実装だけのときはインターフェース名）
     * that(var_type(new class extends \Exception{}))->isSame('\\Exception');
     * that(var_type(new class implements \JsonSerializable{
     *     public function jsonSerialize(): string { return ''; }
     * }))->isSame('\\JsonSerializable');
     *
     * // phpdoc 形式
     * that(var_type([
     *     'scalar'    => 123,
     *     'lish-hash' => [
     *         ['id' => 1, 'name' => 'a'],
     *         ['id' => 2, 'name' => 'b'],
     *     ],
     *     'nest'      => [
     *         'a' => [
     *             'b' => [
     *                 'c' => ['a', 'b', 'c'],
     *             ],
     *         ],
     *     ],
     * ], ['phpdoc' => true, 'format' => 9]))->is(<<<ARRAYSHAPE
     * array{
     *   "lish-hash": array<array{
     *     id: int,
     *     name: string
     *   }>,
     *   nest: array{
     *     a: array{
     *       b: array{
     *         c: array<string>
     *       }
     *     }
     *   },
     *   scalar: int
     * }
     * ARRAYSHAPE);
     * ```
     *
     * @package ryunosuke\Functions\Package\var
     */
    function var_type(
        /** 型を取得する値 */ mixed $var,
        /** オプション配列 */ array $options = [],
    ): /** 型名 */ string
    {
        $options['phpdoc'] ??= false;                             // phpdoc 形式で書き出すか
        $options['format'] ??= 1;                                 // フォーマットレベル（0:no space, 1:separator only, ...9:pretty）
        $options['is_list'] ??= fn($k, $v, $array) => is_int($k); // 連番配列の判定処理（例えば UUID などを連番として扱いたいことがある）
        $options['is_object'] ??= function ($var) {               // object-shape 記法にするオブジェクトの判定処理
            if (is_object($var)) {
                if ($var instanceof \stdClass) {
                    return true;
                }
                /** @noinspection PhpElementIsNotAvailableInCurrentPhpVersionInspection */
                if (count((new \ReflectionClass($var))->getAttributes(\AllowDynamicProperties::class))) {
                    return true;
                }
            }
            return false;
        };

        $options['nest'] = 0;

        if (is_array($var) || $options['is_object']($var)) {
            if ($options['phpdoc']) {
                $shape = new class($var, $options) {
                    private string $shape;
                    private array  $type     = [];
                    private array  $list     = [];
                    private array  $hash     = [];
                    private array  $object   = [];
                    private bool   $optional = false;
                    private array  $options;

                    private string $result;

                    public function __construct($var, $options)
                    {
                        $this->shape = is_object($var) ? 'object' : 'array';
                        $this->options = $options;

                        if (is_array($var) || $this->options['is_object']($var)) {
                            foreach ($var as $k => $v) {
                                if ($this->options['is_list']($k, $v, $var)) {
                                    $new = new self($v, $this->options);
                                    foreach ($this->list as $n => $old) {
                                        /** @var self $old */
                                        if (type_exists($newtype = (string) $new) && type_exists($oldtype = (string) $old)) {
                                            if (is_subclass_of($newtype, $oldtype)) {
                                                $this->list[$n] = $new;
                                                continue 2;
                                            }
                                            if (is_subclass_of($oldtype, $newtype)) {
                                                continue 2;
                                            }
                                        }

                                        if ($new->list xor $old->list) {
                                            if ($new->list && !$old->list) {
                                                $this->list[$n] = $new;
                                                continue 2;
                                            }
                                            if (!$new->list && $old->list) {
                                                continue 2;
                                            }
                                        }

                                        $flag = false;
                                        foreach (['hash', 'object'] as $property) {
                                            if ($new->$property && $old->$property) {
                                                $flag = true;
                                                $diffs = array_diff_key($new->$property, $old->$property) + array_diff_key($old->$property, $new->$property);

                                                foreach ($diffs as $diff) {
                                                    /** @var self $diff */
                                                    unset($diff->result);
                                                    $diff->optional = true;
                                                }
                                                $old->$property += $diffs;

                                                foreach ($old->$property as $name => $diff) {
                                                    unset($diff->result);
                                                    $diff->type = array_merge($diff->type, $new->$property[$name]?->type ?? []);
                                                    $diff->list = array_merge($diff->list, $new->$property[$name]?->list ?? []);
                                                    $diff->hash = array_merge($diff->hash, $new->$property[$name]?->hash ?? []);
                                                    $diff->object = array_merge($diff->object, $new->$property[$name]?->object ?? []);
                                                }
                                            }
                                        }
                                        if ($flag) {
                                            continue 2;
                                        }
                                    }
                                    $this->list[] = $new;
                                }
                                else {
                                    $new = new self($v, ['nest' => $this->options['nest'] + 1] + $this->options);
                                    if (is_object($var)) {
                                        $type = var_type($var, ['is_object' => fn() => false] + $this->options);
                                        if ($type !== 'object') {
                                            $this->type[] = $type;
                                        }
                                        $this->object[$k] = $new;
                                    }
                                    else {
                                        $this->hash[$k] = $new;
                                    }
                                }
                            }
                        }
                        else {
                            $this->type[] = var_type($var, $this->options);
                        }
                    }

                    public function __toString(): string
                    {
                        return $this->result ??= (function () {
                            $result = [];
                            if ($t = array_filter(array_map('strval', $this->type), 'strlen')) {
                                sort($t);
                                $result[] = $t ? implode('|', array_unique($t)) : "";
                            }
                            if ($t = array_filter(array_map('strval', $this->list), 'strlen')) {
                                sort($t);
                                $result[] = $t ? "array<" . implode('|', array_unique($t)) . ">" : "";
                            }
                            foreach (['hash', 'object'] as $property) {
                                if ($t = array_filter(array_map('strval', $this->$property), 'strlen')) {
                                    $space = $this->options['format'] > 0 ? " " : "";
                                    $break = $this->options['format'] > 1 ? "\n" : "";
                                    $delim = $this->options['format'] > 1 ? $break : $space;
                                    $indent = $this->options['format'] > 1 ? "  " : "";
                                    $indent0 = $this->options['format'] > 1 ? str_repeat($indent, $this->options['nest'] + 0) : "";
                                    $indent1 = $this->options['format'] > 1 ? str_repeat($indent, $this->options['nest'] + 1) : "";

                                    ksort($t);
                                    $keyvalues = array_map(function ($v, $k) use ($property, $indent1, $space) {
                                        if (!preg_match('#^[a-zA-Z_\x80-\xff][a-zA-Z0-9_\x80-\xff]*$#u', $k)) {
                                            $k = str_quote($k);
                                        }
                                        if ($this->$property[$k]->optional ?? false) {
                                            $k = "$k?";
                                        }
                                        return "{$indent1}$k:{$space}$v";
                                    }, $t, array_keys($t));
                                    $result[] = $t ? "{$this->shape}{{$break}" . implode(",{$delim}", $keyvalues) . "{$break}{$indent0}}" : "";
                                }
                            }
                            $result = array_filter($result, 'strlen');
                            return $result ? implode('|', $result) : $this->shape;
                        })();
                    }

                    /** @codeCoverageIgnore */
                    public function __debugInfo(): ?array
                    {
                        return [
                            'type'     => $this->type,
                            'list'     => $this->list,
                            'hash'     => $this->hash,
                            'object'   => $this->object,
                            'optional' => $this->optional,
                        ];
                    }
                };
                //var_pretty($shape);
                return (string) $shape;
            }
        }
        if (is_object($var)) {
            if ($options['phpdoc']) {
                // クロージャだけはどうせ情報量がゼロなので特別扱いにする
                if ($var instanceof \Closure) {
                    $space = $options['format'] > 0 ? " " : "";

                    $ref = new \ReflectionFunction($var);
                    $args = array_map(fn($p) => ($p->getType() ?? "mixed") . ($p->isVariadic() ? '...' : ''), $ref->getParameters());
                    $return = ($ref->getReturnType() ?? 'mixed');
                    $return = is_string($return) || $return instanceof \ReflectionNamedType ? $return : "($return)";
                    return "\\Closure(" . implode(",$space", $args) . "):$space" . reflect_type_resolve($return);
                }

                $types = [];
                $ref = new \ReflectionObject($var);
                if ($ref->isAnonymous()) {
                    $ifs = [];
                    if ($pc = $ref->getParentClass()) {
                        $types[] = $pc->name;
                        $ifs = $pc->getInterfaceNames();
                    }
                    $types = array_merge($types, array_diff($ref->getInterfaceNames(), $ifs));
                }
                else {
                    $types[] = get_class($var);
                }
                if (!$types) {
                    return 'object';
                }
                return implode('|', array_map(fn($v) => "\\" . ltrim($v, '\\'), $types));
            }
            $ref = new \ReflectionObject($var);
            if ($ref->isAnonymous()) {
                if ($pc = $ref->getParentClass()) {
                    return '\\' . $pc->name;
                }
                if ($is = $ref->getInterfaceNames()) {
                    return '\\' . reset($is);
                }
            }
            return '\\' . get_class($var);
        }
        if (is_resourcable($var)) {
            return 'resource';
        }

        return get_debug_type($var);
    }
}
